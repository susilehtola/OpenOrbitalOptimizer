{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v020-2025-mm-dd-unreleased","title":"v0.2.0 / 2025-MM-DD (Unreleased)","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/#new-features","title":"New Features","text":""},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li>MESA should use Aufbau occupations not MOM</li> <li>Undo minimum error criterion by Garza and Scuseria to avoid penalizing large steps leading to a decrease in energy</li> <li>Increase <code>pure_ediis_factor</code></li> <li>Implement callback functionality</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/#misc","title":"Misc.","text":"<ul> <li>Fix GCC 15 warnings</li> </ul>"},{"location":"changelog/#v010-2025-03-30","title":"v0.1.0 / 2025-03-30","text":""},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>#20 Intf -- allow OOO and    IntegratorXX to work on Windows.</li> <li>All start-up functionality making library operational.</li> </ul>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>OpenOrbitalOptimizer</code> project code.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"},{"location":"OOOApi/","title":"API documentation for OpenOrbitalOptimizer","text":"<p>Documentation is generated by mkdoxy.</p>"},{"location":"OOOApi/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace OpenOrbitalOptimizer <ul> <li>namespace ConjugateGradients </li> <li>class SCFSolver SCF solver class. </li> </ul> </li> </ul>"},{"location":"OOOApi/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir openorbitaloptimizer <ul> <li>file cg_optimizer.hpp </li> <li>file scfsolver.hpp </li> </ul> </li> </ul>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/","title":"Namespace OpenOrbitalOptimizer","text":"<p>Namespace List &gt; OpenOrbitalOptimizer</p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#namespaces","title":"Namespaces","text":"Type Name namespace ConjugateGradients"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#classes","title":"Classes","text":"Type Name class SCFSolver &lt;typename Torb, typename Tbase&gt;SCF solver class."},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#public-types","title":"Public Types","text":"Type Name typedef std::pair&lt; Orbitals&lt; Torb &gt;, OrbitalOccupations&lt; Tbase &gt; &gt; DensityMatrix The pair of orbitals and occupations defines the density matrix. typedef arma::Mat&lt; T &gt; DiagonalOrbitalHessianBlock typedef std::vector&lt; DiagonalOrbitalHessianBlock&lt; T &gt; &gt; DiagonalOrbitalHessians typedef std::pair&lt; Orbitals&lt; Torb &gt;, OrbitalEnergies&lt; Tbase &gt; &gt; DiagonalizedFockMatrix The return of Fock matrix diagonalization is. typedef std::function&lt; FockBuilderReturn&lt; Torb, Tbase &gt;(const DensityMatrix&lt; Torb, Tbase &gt; &amp;)&gt; FockBuilder typedef std::pair&lt; Tbase, FockMatrix&lt; Torb &gt; &gt; FockBuilderReturn typedef std::vector&lt; FockMatrixBlock&lt; T &gt; &gt; FockMatrix The whole set of Fock matrices is a vector of blocks. typedef arma::Mat&lt; T &gt; FockMatrixBlock typedef arma::Mat&lt; T &gt; OrbitalBlock typedef arma::Col&lt; T &gt; OrbitalBlockOccupations The occupations for each orbitals are floating point numbers. typedef std::vector&lt; arma::Col&lt; T &gt; &gt; OrbitalEnergies Orbital energies are stored as a vector of vectors. typedef arma::Mat&lt; T &gt; OrbitalGradientBlock typedef std::vector&lt; OrbitalGradientBlock&lt; T &gt; &gt; OrbitalGradients typedef std::vector&lt; OrbitalHistoryEntry&lt; Torb, Tbase &gt; &gt; OrbitalHistory The history is then a vector. typedef std::tuple&lt; DensityMatrix&lt; Torb, Tbase &gt;, FockBuilderReturn&lt; Torb, Tbase &gt;, size_t &gt; OrbitalHistoryEntry typedef std::vector&lt; OrbitalBlockOccupations&lt; T &gt; &gt; OrbitalOccupations typedef std::tuple&lt; size_t, arma::uword, arma::uword &gt; OrbitalRotation List of orbital rotation angles: block index and orbital indices. typedef std::vector&lt; OrbitalBlock&lt; T &gt; &gt; Orbitals"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-densitymatrix","title":"typedef DensityMatrix","text":"<p>The pair of orbitals and occupations defines the density matrix. </p> <pre><code>using OpenOrbitalOptimizer::DensityMatrix =  std::pair&lt;Orbitals&lt;Torb&gt;,OrbitalOccupations&lt;Tbase&gt;&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-diagonalorbitalhessianblock","title":"typedef DiagonalOrbitalHessianBlock","text":"<pre><code>using OpenOrbitalOptimizer::DiagonalOrbitalHessianBlock =  arma::Mat&lt;T&gt;;\n</code></pre> <p>A symmetry block of diagonal orbital Hessians is defined by the corresponding N x N matrix </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-diagonalorbitalhessians","title":"typedef DiagonalOrbitalHessians","text":"<pre><code>using OpenOrbitalOptimizer::DiagonalOrbitalHessians =  std::vector&lt;DiagonalOrbitalHessianBlock&lt;T&gt;&gt;;\n</code></pre> <p>The set of diagonal orbital Hessians is defined by a vector of orbital blocks, corresponding to each symmetry block of each particle type </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-diagonalizedfockmatrix","title":"typedef DiagonalizedFockMatrix","text":"<p>The return of Fock matrix diagonalization is. </p> <pre><code>using OpenOrbitalOptimizer::DiagonalizedFockMatrix =  std::pair&lt;Orbitals&lt;Torb&gt;,OrbitalEnergies&lt;Tbase&gt;&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-fockbuilder","title":"typedef FockBuilder","text":"<pre><code>using OpenOrbitalOptimizer::FockBuilder =  std::function&lt;FockBuilderReturn&lt;Torb, Tbase&gt;(const DensityMatrix&lt;Torb, Tbase&gt; &amp;)&gt;;\n</code></pre> <p>The Fock builder takes in the orbitals and orbital occupations, and returns the energy and Fock matrices </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-fockbuilderreturn","title":"typedef FockBuilderReturn","text":"<pre><code>using OpenOrbitalOptimizer::FockBuilderReturn =  std::pair&lt;Tbase, FockMatrix&lt;Torb&gt;&gt;;\n</code></pre> <p>The Fock matrix builder returns the energy and the Fock matrices for each orbital block </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-fockmatrix","title":"typedef FockMatrix","text":"<p>The whole set of Fock matrices is a vector of blocks. </p> <pre><code>using OpenOrbitalOptimizer::FockMatrix =  std::vector&lt;FockMatrixBlock&lt;T&gt;&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-fockmatrixblock","title":"typedef FockMatrixBlock","text":"<pre><code>using OpenOrbitalOptimizer::FockMatrixBlock =  arma::Mat&lt;T&gt;;\n</code></pre> <p>A symmetry block in a Fock matrix is likewise defined by a N x N matrix </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalblock","title":"typedef OrbitalBlock","text":"<pre><code>using OpenOrbitalOptimizer::OrbitalBlock =  arma::Mat&lt;T&gt;;\n</code></pre> <p>A symmetry block of orbitals is defined by the corresponding N x N matrix of orbital coefficients </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalblockoccupations","title":"typedef OrbitalBlockOccupations","text":"<p>The occupations for each orbitals are floating point numbers. </p> <pre><code>using OpenOrbitalOptimizer::OrbitalBlockOccupations =  arma::Col&lt;T&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalenergies","title":"typedef OrbitalEnergies","text":"<p>Orbital energies are stored as a vector of vectors. </p> <pre><code>using OpenOrbitalOptimizer::OrbitalEnergies =  std::vector&lt;arma::Col&lt;T&gt;&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalgradientblock","title":"typedef OrbitalGradientBlock","text":"<pre><code>using OpenOrbitalOptimizer::OrbitalGradientBlock =  arma::Mat&lt;T&gt;;\n</code></pre> <p>A symmetry block of orbital gradients is defined by the corresponding N x N matrix </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalgradients","title":"typedef OrbitalGradients","text":"<pre><code>using OpenOrbitalOptimizer::OrbitalGradients =  std::vector&lt;OrbitalGradientBlock&lt;T&gt;&gt;;\n</code></pre> <p>The set of orbital gradients is defined by a vector of orbital blocks, corresponding to each symmetry block of each particle type </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalhistory","title":"typedef OrbitalHistory","text":"<p>The history is then a vector. </p> <pre><code>using OpenOrbitalOptimizer::OrbitalHistory =  std::vector&lt;OrbitalHistoryEntry&lt;Torb, Tbase&gt;&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalhistoryentry","title":"typedef OrbitalHistoryEntry","text":"<pre><code>using OpenOrbitalOptimizer::OrbitalHistoryEntry =  std::tuple&lt;DensityMatrix&lt;Torb, Tbase&gt;, FockBuilderReturn&lt;Torb, Tbase&gt;, size_t&gt;;\n</code></pre> <p>The history of orbital optimization is defined by the orbitals and their occupations - together the density matrix - and the resulting energy and Fock matrix </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitaloccupations","title":"typedef OrbitalOccupations","text":"<pre><code>using OpenOrbitalOptimizer::OrbitalOccupations =  std::vector&lt;OrbitalBlockOccupations&lt;T&gt;&gt;;\n</code></pre> <p>The occupations for the whole set of orbitals are again a vector </p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitalrotation","title":"typedef OrbitalRotation","text":"<p>List of orbital rotation angles: block index and orbital indices. </p> <pre><code>using OpenOrbitalOptimizer::OrbitalRotation =  std::tuple&lt;size_t, arma::uword, arma::uword&gt;;\n</code></pre>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer/#typedef-orbitals","title":"typedef Orbitals","text":"<pre><code>using OpenOrbitalOptimizer::Orbitals =  std::vector&lt;OrbitalBlock&lt;T&gt;&gt;;\n</code></pre> <p>The set of orbitals is defined by a vector of orbital blocks, corresponding to each symmetry block of each particle type </p> <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/cg_optimizer.hpp</code></p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer_1_1ConjugateGradients/","title":"Namespace OpenOrbitalOptimizer::ConjugateGradients","text":"<p>Namespace List &gt; OpenOrbitalOptimizer &gt; ConjugateGradients</p>"},{"location":"OOOApi/namespaceOpenOrbitalOptimizer_1_1ConjugateGradients/#public-functions","title":"Public Functions","text":"Type Name arma::Col&lt; T &gt; cg_optimize (const arma::Col&lt; T &gt; &amp; x0, const std::function&lt; std::pair&lt; T, arma::Col&lt; T &gt; &gt;(arma::Col&lt; T &gt;)&gt; &amp; fx, T f_tol=1e-8, T df_tol=1e-6, T x_tol=100 *std::numeric_limits&lt; T &gt;::epsilon(), size_t max_iter=1000) Conjugate gradient optimization."},{"location":"OOOApi/namespaceOpenOrbitalOptimizer_1_1ConjugateGradients/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"OOOApi/namespaceOpenOrbitalOptimizer_1_1ConjugateGradients/#function-cg_optimize","title":"function cg_optimize","text":"<p>Conjugate gradient optimization. </p> <pre><code>template&lt;typename T&gt;\narma::Col&lt; T &gt; OpenOrbitalOptimizer::ConjugateGradients::cg_optimize (\n    const arma::Col&lt; T &gt; &amp; x0,\n    const std::function&lt; std::pair&lt; T, arma::Col&lt; T &gt; &gt;(arma::Col&lt; T &gt;)&gt; &amp; fx,\n    T f_tol=1e-8,\n    T df_tol=1e-6,\n    T x_tol=100 *std::numeric_limits&lt; T &gt;::epsilon(),\n    size_t max_iter=1000\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/cg_optimizer.hpp</code></p>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/","title":"Class OpenOrbitalOptimizer::SCFSolver","text":"<p>template &lt;typename Torb, typename Tbase&gt;</p> <p>ClassList &gt; OpenOrbitalOptimizer &gt; SCFSolver</p> <p>SCF solver class. </p> <ul> <li><code>#include &lt;scfsolver.hpp&gt;</code></li> </ul>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#public-functions","title":"Public Functions","text":"Type Name SCFSolver (const arma::uvec &amp; number_of_blocks_per_particle_type, const arma::Col&lt; Tbase &gt; &amp; maximum_occupation, const arma::Col&lt; Tbase &gt; &amp; number_of_particles, const FockBuilder&lt; Torb, Tbase &gt; &amp; fock_builder, const std::vector&lt; std::string &gt; &amp; block_descriptions) Constructor. bool add_entry (const DensityMatrix&lt; Torb, Tbase &gt; &amp; density) Add entry to history, return value is True if energy was lowered. bool add_entry (const DensityMatrix&lt; Torb, Tbase &gt; &amp; density, const FockBuilderReturn&lt; Torb, Tbase &gt; &amp; fock) Add entry to history, return value is True if energy was lowered. void brute_force_search_for_lowest_configuration () Finds the lowest \"Aufbau\" configuration by moving particles between symmetries by brute force search. void callback_function (std::function&lt; void(const std::map&lt; std::string, std::any &gt; &amp;)&gt; callback_function=nullptr)  DiagonalizedFockMatrix&lt; Torb, Tbase &gt; compute_orbitals (const FockMatrix&lt; Torb &gt; &amp; fock) constComputes orbitals and orbital energies by diagonalizing the Fock matrix. bool converged () constCheck if we are converged. Tbase convergence_threshold () constGet convergence threshold. void convergence_threshold (Tbase convergence_threshold) Set verbosity. Tbase density_matrix_difference (size_t ihist, size_t jhist) Density matrix difference norm. arma::Col&lt; Tbase &gt; determine_number_of_particles_by_aufbau (const OrbitalEnergies&lt; Tbase &gt; &amp; orbital_energies) constDetermine number of particles in each block. Tbase diis_diagonal_damping () constDamping factor for DIIS diagonal. void diis_diagonal_damping (Tbase eps) Damping factor for DIIS diagonal. Tbase diis_epsilon () constWhen to start mixing in DIIS. void diis_epsilon (Tbase eps) When to start mixing in DIIS. Tbase diis_restart_factor () constDIIS restart criterion. void diis_restart_factor (Tbase eps) DIIS restart criterion. Tbase diis_threshold () constWhen to switch over to DIIS. void diis_threshold (Tbase eps) When to switch over to DIIS. std::string error_norm () constGet the used error norm. void error_norm (const std::string &amp; error_norm) Set the used error norm. void fixed_number_of_particles_per_block (const arma::Col&lt; Tbase &gt; &amp; number_of_particles_per_block) Fix the number of occupied orbitals per block. bool frozen_occupations () constGet frozen occupations. void frozen_occupations (bool frozen) Set frozen occupations. Tbase get_energy (size_t ihist=0) constGet the energy for the n:th entry. FockBuilderReturn&lt; Torb, Tbase &gt; get_fock_build (size_t ihist=0) constGet the Fock matrix builder return. FockMatrix&lt; Torb &gt; get_fock_matrix (size_t ihist=0) constGet the Fock matrix for the ihist:th entry. OrbitalOccupations&lt; Tbase &gt; get_orbital_occupations (size_t ihist=0) constGet the orbital occupations. Orbitals&lt; Torb &gt; get_orbitals (size_t ihist=0) constGet the orbitals. DensityMatrix&lt; Torb, Tbase &gt; get_solution (size_t ihist=0) constGet the SCF solution. void initialize_with_fock (const FockMatrix&lt; Torb &gt; &amp; fock_guess) Initialize the solver with a guess Fock matrix. void initialize_with_orbitals (const Orbitals&lt; Torb &gt; &amp; orbitals, const OrbitalOccupations&lt; Tbase &gt; &amp; orbital_occupations) Initialize with precomputed orbitals and occupations. int maximum_history_length () constGet maximum_history_length. void maximum_history_length (int maximum_history_length) Set maximum_history_length. size_t maximum_iterations () constGet the maximum number of iterations. void maximum_iterations (size_t maxit) Set the maximum number of iterations. Tbase norm (const arma::Mat&lt; Tbase &gt; &amp; mat, std::string norm=\"\") constEvaluate the norm. Tbase optimal_damping_threshold () constUse optimal damping when max error bigger than this. void optimal_damping_threshold (Tbase eps) Use optimal damping when max error bigger than this. arma::uword particle_block_offset (size_t iparticle) constDetermines the offset for the blocks of the iparticle:th particle. void print_history () constPrint the DIIS history. void reset_history () Reset the DIIS history. void run () Run the SCF. void run_optimal_damping () Run optimal damping. OrbitalOccupations&lt; Tbase &gt; update_occupations (const OrbitalEnergies&lt; Tbase &gt; &amp; orbital_energies) constDetermines occupations based on the current orbital energies. int verbosity () constGet verbosity. void verbosity (int verbosity) Set verbosity."},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-scfsolver","title":"function SCFSolver","text":"<p>Constructor. </p> <pre><code>inline OpenOrbitalOptimizer::SCFSolver::SCFSolver (\n    const arma::uvec &amp; number_of_blocks_per_particle_type,\n    const arma::Col&lt; Tbase &gt; &amp; maximum_occupation,\n    const arma::Col&lt; Tbase &gt; &amp; number_of_particles,\n    const FockBuilder&lt; Torb, Tbase &gt; &amp; fock_builder,\n    const std::vector&lt; std::string &gt; &amp; block_descriptions\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-add_entry-12","title":"function add_entry [1/2]","text":"<p>Add entry to history, return value is True if energy was lowered. </p> <pre><code>inline bool OpenOrbitalOptimizer::SCFSolver::add_entry (\n    const DensityMatrix&lt; Torb, Tbase &gt; &amp; density\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-add_entry-22","title":"function add_entry [2/2]","text":"<p>Add entry to history, return value is True if energy was lowered. </p> <pre><code>inline bool OpenOrbitalOptimizer::SCFSolver::add_entry (\n    const DensityMatrix&lt; Torb, Tbase &gt; &amp; density,\n    const FockBuilderReturn&lt; Torb, Tbase &gt; &amp; fock\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-brute_force_search_for_lowest_configuration","title":"function brute_force_search_for_lowest_configuration","text":"<p>Finds the lowest \"Aufbau\" configuration by moving particles between symmetries by brute force search. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::brute_force_search_for_lowest_configuration () \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-callback_function","title":"function callback_function","text":"<pre><code>inline void OpenOrbitalOptimizer::SCFSolver::callback_function (\n    std::function&lt; void(const std::map&lt; std::string, std::any &gt; &amp;)&gt; callback_function=nullptr\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-compute_orbitals","title":"function compute_orbitals","text":"<p>Computes orbitals and orbital energies by diagonalizing the Fock matrix. </p> <pre><code>inline DiagonalizedFockMatrix&lt; Torb, Tbase &gt; OpenOrbitalOptimizer::SCFSolver::compute_orbitals (\n    const FockMatrix&lt; Torb &gt; &amp; fock\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-converged","title":"function converged","text":"<p>Check if we are converged. </p> <pre><code>inline bool OpenOrbitalOptimizer::SCFSolver::converged () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-convergence_threshold-12","title":"function convergence_threshold [1/2]","text":"<p>Get convergence threshold. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::convergence_threshold () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-convergence_threshold-22","title":"function convergence_threshold [2/2]","text":"<p>Set verbosity. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::convergence_threshold (\n    Tbase convergence_threshold\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-density_matrix_difference","title":"function density_matrix_difference","text":"<p>Density matrix difference norm. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::density_matrix_difference (\n    size_t ihist,\n    size_t jhist\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-determine_number_of_particles_by_aufbau","title":"function determine_number_of_particles_by_aufbau","text":"<p>Determine number of particles in each block. </p> <pre><code>inline arma::Col&lt; Tbase &gt; OpenOrbitalOptimizer::SCFSolver::determine_number_of_particles_by_aufbau (\n    const OrbitalEnergies&lt; Tbase &gt; &amp; orbital_energies\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_diagonal_damping-12","title":"function diis_diagonal_damping [1/2]","text":"<p>Damping factor for DIIS diagonal. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::diis_diagonal_damping () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_diagonal_damping-22","title":"function diis_diagonal_damping [2/2]","text":"<p>Damping factor for DIIS diagonal. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::diis_diagonal_damping (\n    Tbase eps\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_epsilon-12","title":"function diis_epsilon [1/2]","text":"<p>When to start mixing in DIIS. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::diis_epsilon () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_epsilon-22","title":"function diis_epsilon [2/2]","text":"<p>When to start mixing in DIIS. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::diis_epsilon (\n    Tbase eps\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_restart_factor-12","title":"function diis_restart_factor [1/2]","text":"<p>DIIS restart criterion. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::diis_restart_factor () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_restart_factor-22","title":"function diis_restart_factor [2/2]","text":"<p>DIIS restart criterion. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::diis_restart_factor (\n    Tbase eps\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_threshold-12","title":"function diis_threshold [1/2]","text":"<p>When to switch over to DIIS. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::diis_threshold () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-diis_threshold-22","title":"function diis_threshold [2/2]","text":"<p>When to switch over to DIIS. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::diis_threshold (\n    Tbase eps\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-error_norm-12","title":"function error_norm [1/2]","text":"<p>Get the used error norm. </p> <pre><code>inline std::string OpenOrbitalOptimizer::SCFSolver::error_norm () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-error_norm-22","title":"function error_norm [2/2]","text":"<p>Set the used error norm. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::error_norm (\n    const std::string &amp; error_norm\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-fixed_number_of_particles_per_block","title":"function fixed_number_of_particles_per_block","text":"<p>Fix the number of occupied orbitals per block. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::fixed_number_of_particles_per_block (\n    const arma::Col&lt; Tbase &gt; &amp; number_of_particles_per_block\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-frozen_occupations-12","title":"function frozen_occupations [1/2]","text":"<p>Get frozen occupations. </p> <pre><code>inline bool OpenOrbitalOptimizer::SCFSolver::frozen_occupations () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-frozen_occupations-22","title":"function frozen_occupations [2/2]","text":"<p>Set frozen occupations. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::frozen_occupations (\n    bool frozen\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_energy","title":"function get_energy","text":"<p>Get the energy for the n:th entry. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::get_energy (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_fock_build","title":"function get_fock_build","text":"<p>Get the Fock matrix builder return. </p> <pre><code>inline FockBuilderReturn&lt; Torb, Tbase &gt; OpenOrbitalOptimizer::SCFSolver::get_fock_build (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_fock_matrix","title":"function get_fock_matrix","text":"<p>Get the Fock matrix for the ihist:th entry. </p> <pre><code>inline FockMatrix&lt; Torb &gt; OpenOrbitalOptimizer::SCFSolver::get_fock_matrix (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_orbital_occupations","title":"function get_orbital_occupations","text":"<p>Get the orbital occupations. </p> <pre><code>inline OrbitalOccupations&lt; Tbase &gt; OpenOrbitalOptimizer::SCFSolver::get_orbital_occupations (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_orbitals","title":"function get_orbitals","text":"<p>Get the orbitals. </p> <pre><code>inline Orbitals&lt; Torb &gt; OpenOrbitalOptimizer::SCFSolver::get_orbitals (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-get_solution","title":"function get_solution","text":"<p>Get the SCF solution. </p> <pre><code>inline DensityMatrix&lt; Torb, Tbase &gt; OpenOrbitalOptimizer::SCFSolver::get_solution (\n    size_t ihist=0\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-initialize_with_fock","title":"function initialize_with_fock","text":"<p>Initialize the solver with a guess Fock matrix. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::initialize_with_fock (\n    const FockMatrix&lt; Torb &gt; &amp; fock_guess\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-initialize_with_orbitals","title":"function initialize_with_orbitals","text":"<p>Initialize with precomputed orbitals and occupations. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::initialize_with_orbitals (\n    const Orbitals&lt; Torb &gt; &amp; orbitals,\n    const OrbitalOccupations&lt; Tbase &gt; &amp; orbital_occupations\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-maximum_history_length-12","title":"function maximum_history_length [1/2]","text":"<p>Get maximum_history_length. </p> <pre><code>inline int OpenOrbitalOptimizer::SCFSolver::maximum_history_length () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-maximum_history_length-22","title":"function maximum_history_length [2/2]","text":"<p>Set maximum_history_length. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::maximum_history_length (\n    int maximum_history_length\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-maximum_iterations-12","title":"function maximum_iterations [1/2]","text":"<p>Get the maximum number of iterations. </p> <pre><code>inline size_t OpenOrbitalOptimizer::SCFSolver::maximum_iterations () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-maximum_iterations-22","title":"function maximum_iterations [2/2]","text":"<p>Set the maximum number of iterations. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::maximum_iterations (\n    size_t maxit\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-norm","title":"function norm","text":"<p>Evaluate the norm. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::norm (\n    const arma::Mat&lt; Tbase &gt; &amp; mat,\n    std::string norm=\"\"\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-optimal_damping_threshold-12","title":"function optimal_damping_threshold [1/2]","text":"<p>Use optimal damping when max error bigger than this. </p> <pre><code>inline Tbase OpenOrbitalOptimizer::SCFSolver::optimal_damping_threshold () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-optimal_damping_threshold-22","title":"function optimal_damping_threshold [2/2]","text":"<p>Use optimal damping when max error bigger than this. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::optimal_damping_threshold (\n    Tbase eps\n) \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-particle_block_offset","title":"function particle_block_offset","text":"<p>Determines the offset for the blocks of the iparticle:th particle. </p> <pre><code>inline arma::uword OpenOrbitalOptimizer::SCFSolver::particle_block_offset (\n    size_t iparticle\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-print_history","title":"function print_history","text":"<p>Print the DIIS history. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::print_history () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-reset_history","title":"function reset_history","text":"<p>Reset the DIIS history. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::reset_history () \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-run","title":"function run","text":"<p>Run the SCF. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::run () \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-run_optimal_damping","title":"function run_optimal_damping","text":"<p>Run optimal damping. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::run_optimal_damping () \n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-update_occupations","title":"function update_occupations","text":"<p>Determines occupations based on the current orbital energies. </p> <pre><code>inline OrbitalOccupations&lt; Tbase &gt; OpenOrbitalOptimizer::SCFSolver::update_occupations (\n    const OrbitalEnergies&lt; Tbase &gt; &amp; orbital_energies\n) const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-verbosity-12","title":"function verbosity [1/2]","text":"<p>Get verbosity. </p> <pre><code>inline int OpenOrbitalOptimizer::SCFSolver::verbosity () const\n</code></pre>"},{"location":"OOOApi/classOpenOrbitalOptimizer_1_1SCFSolver/#function-verbosity-22","title":"function verbosity [2/2]","text":"<p>Set verbosity. </p> <pre><code>inline void OpenOrbitalOptimizer::SCFSolver::verbosity (\n    int verbosity\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/scfsolver.hpp</code></p>"},{"location":"OOOApi/dir_3072c93c56dfbbd2cb4eee0809487533/","title":"Dir openorbitaloptimizer","text":"<p>FileList &gt; openorbitaloptimizer</p>"},{"location":"OOOApi/dir_3072c93c56dfbbd2cb4eee0809487533/#files","title":"Files","text":"Type Name file cg_optimizer.hpp file scfsolver.hpp <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/</code></p>"},{"location":"OOOApi/cg__optimizer_8hpp/","title":"File cg_optimizer.hpp","text":"<p>FileList &gt; openorbitaloptimizer &gt; cg_optimizer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"OOOApi/cg__optimizer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace OpenOrbitalOptimizer namespace ConjugateGradients <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/cg_optimizer.hpp</code></p>"},{"location":"OOOApi/cg__optimizer_8hpp_source/","title":"File cg_optimizer.hpp","text":"<p>File List &gt; openorbitaloptimizer &gt; cg_optimizer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n Copyright (C) 2023- Susi Lehtola\n\n This Source Code Form is subject to the terms of the Mozilla Public\n License, v. 2.0. If a copy of the MPL was not distributed with this\n file, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n\n#pragma once\n#include &lt;armadillo&gt;\n\nnamespace OpenOrbitalOptimizer {\n  namespace ConjugateGradients {\n\n    template&lt;typename T&gt;\n    arma::Col&lt;T&gt; cg_optimize(const arma::Col&lt;T&gt; &amp; x0, const std::function&lt;std::pair&lt;T,arma::Col&lt;T&gt;&gt;(arma::Col&lt;T&gt;)&gt; &amp; fx, T f_tol = 1e-8, T df_tol = 1e-6, T x_tol = 100*std::numeric_limits&lt;T&gt;::epsilon(), size_t max_iter = 1000) {\n      auto x(x0);\n      auto current_point = fx(x);\n\n      arma::Col&lt;T&gt; current_gradient, previous_gradient;\n      arma::Col&lt;T&gt; current_direction, previous_direction;\n      for(size_t iteration = 0; iteration &lt; max_iter; iteration++) {\n        previous_gradient = current_gradient;\n        current_gradient = current_point.second;\n\n        previous_direction = current_direction;\n        current_direction = -current_gradient;\n        if(iteration&gt;0) {\n          auto gamma = arma::dot(current_gradient,current_gradient-previous_gradient)/arma::dot(previous_gradient, previous_gradient);\n          current_direction += gamma*previous_direction;\n        }\n        if(arma::dot(current_direction, current_gradient) &gt; 0.0)\n          current_direction = -current_gradient;\n\n        //printf(\"Optimization iteration %i: gradient norm %e\\n\",iteration, arma::norm(current_gradient,2));\n        if(arma::norm(current_gradient,2)&lt;df_tol)\n          break;\n\n        std::function&lt;T(T)&gt; evaluate_step = [x, fx, current_direction](T step) {\n          return fx(x + step*current_direction).first;\n        };\n\n        auto step_lengths = arma::logspace&lt;arma::Col&lt;T&gt;&gt;(-6.0,6.0,13);\n        arma::Col&lt;T&gt; function_values(step_lengths.n_elem);\n        for(size_t i=0;i&lt;step_lengths.n_elem;i++)\n          function_values[i] = evaluate_step(step_lengths(i));\n\n        arma::uword minidx;\n        function_values.min(minidx);\n        if(minidx==0 || minidx==step_lengths.n_elem-1)\n          throw std::logic_error(\"Issue in line search\\n\");\n\n        const double golden_ratio = (1+sqrt(5.0))/2.0;\n        T right_bracket = step_lengths[minidx+1];\n        T left_bracket = step_lengths[minidx-1];\n        while(std::abs(right_bracket - left_bracket) &gt; 0.5*x_tol*(left_bracket+right_bracket)) {\n          //printf(\"left % e right % e length %e\\n\",left_bracket,right_bracket,std::abs(right_bracket - left_bracket));\n          T test_left = right_bracket - (right_bracket-left_bracket) / golden_ratio;\n          T test_right = left_bracket + (right_bracket-left_bracket) / golden_ratio;\n          if(evaluate_step(test_left) &lt; evaluate_step(test_right)) {\n            right_bracket = test_right;\n          } else {\n            left_bracket = test_left;\n          }\n        }\n        T optimal_step = 0.5*(right_bracket + left_bracket);\n\n        x += optimal_step * current_direction;\n        current_point = fx(x);\n      }\n\n      return x;\n    }\n  }\n}\n</code></pre>"},{"location":"OOOApi/scfsolver_8hpp/","title":"File scfsolver.hpp","text":"<p>FileList &gt; openorbitaloptimizer &gt; scfsolver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"cg_optimizer.hpp\"</code></li> </ul>"},{"location":"OOOApi/scfsolver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace OpenOrbitalOptimizer"},{"location":"OOOApi/scfsolver_8hpp/#classes","title":"Classes","text":"Type Name class SCFSolver &lt;typename Torb, typename Tbase&gt;SCF solver class. <p>The documentation for this class was generated from the following file <code>openorbitaloptimizer/scfsolver.hpp</code></p>"},{"location":"OOOApi/scfsolver_8hpp_source/","title":"File scfsolver.hpp","text":"<p>File List &gt; openorbitaloptimizer &gt; scfsolver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n Copyright (C) 2023- Susi Lehtola\n\n This Source Code Form is subject to the terms of the Mozilla Public\n License, v. 2.0. If a copy of the MPL was not distributed with this\n file, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n\n#pragma once\n#include &lt;any&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;armadillo&gt;\n#include \"cg_optimizer.hpp\"\n\nnamespace OpenOrbitalOptimizer {\n  template&lt;typename T&gt; using OrbitalBlock = arma::Mat&lt;T&gt;;\n  template&lt;typename T&gt; using Orbitals = std::vector&lt;OrbitalBlock&lt;T&gt;&gt;;\n\n  template&lt;typename T&gt; using OrbitalGradientBlock = arma::Mat&lt;T&gt;;\n  template&lt;typename T&gt; using OrbitalGradients = std::vector&lt;OrbitalGradientBlock&lt;T&gt;&gt;;\n\n  template&lt;typename T&gt; using DiagonalOrbitalHessianBlock = arma::Mat&lt;T&gt;;\n  template&lt;typename T&gt; using DiagonalOrbitalHessians = std::vector&lt;DiagonalOrbitalHessianBlock&lt;T&gt;&gt;;\n\n  template&lt;typename T&gt; using OrbitalBlockOccupations = arma::Col&lt;T&gt;;\n  template&lt;typename T&gt; using OrbitalOccupations = std::vector&lt;OrbitalBlockOccupations&lt;T&gt;&gt;;\n\n  template&lt;typename Torb, typename Tbase&gt; using DensityMatrix = std::pair&lt;Orbitals&lt;Torb&gt;,OrbitalOccupations&lt;Tbase&gt;&gt;;\n\n  template&lt;typename T&gt; using OrbitalEnergies = std::vector&lt;arma::Col&lt;T&gt;&gt;;\n\n  template&lt;typename T&gt; using FockMatrixBlock = arma::Mat&lt;T&gt;;\n  template&lt;typename T&gt; using FockMatrix = std::vector&lt;FockMatrixBlock&lt;T&gt;&gt;;\n  template&lt;typename Torb, typename Tbase&gt; using DiagonalizedFockMatrix = std::pair&lt;Orbitals&lt;Torb&gt;,OrbitalEnergies&lt;Tbase&gt;&gt;;\n\n  template&lt;typename Torb, typename Tbase&gt; using FockBuilderReturn = std::pair&lt;Tbase, FockMatrix&lt;Torb&gt;&gt;;\n  template&lt;typename Torb, typename Tbase&gt; using FockBuilder = std::function&lt;FockBuilderReturn&lt;Torb, Tbase&gt;(const DensityMatrix&lt;Torb, Tbase&gt; &amp;)&gt;;\n\n  template&lt;typename Torb, typename Tbase&gt; using OrbitalHistoryEntry = std::tuple&lt;DensityMatrix&lt;Torb, Tbase&gt;, FockBuilderReturn&lt;Torb, Tbase&gt;, size_t&gt;;\n  template&lt;typename Torb, typename Tbase&gt; using OrbitalHistory = std::vector&lt;OrbitalHistoryEntry&lt;Torb, Tbase&gt;&gt;;\n\n  using OrbitalRotation = std::tuple&lt;size_t, arma::uword, arma::uword&gt;;\n\n  template&lt;typename Torb, typename Tbase&gt; class SCFSolver {\n    /* Input data section */\n    arma::uvec number_of_blocks_per_particle_type_;\n    arma::Col&lt;Tbase&gt; maximum_occupation_;\n    arma::Col&lt;Tbase&gt; number_of_particles_;\n    FockBuilder&lt;Torb, Tbase&gt; fock_builder_;\n    std::vector&lt;std::string&gt; block_descriptions_;\n    std::function&lt;void(const std::map&lt;std::string,std::any&gt; &amp; data)&gt; callback_function_;\n\n    arma::Col&lt;Tbase&gt; fixed_number_of_particles_per_block_;\n    bool frozen_occupations_;\n\n    int verbosity_;\n\n    /* Internal data section */\n    size_t number_of_blocks_;\n    OrbitalHistory&lt;Torb, Tbase&gt; orbital_history_;\n    OrbitalOccupations&lt;Tbase&gt; orbital_occupations_;\n\n    size_t number_of_fock_evaluations_ = 0;\n\n    size_t maximum_iterations_ = 128;\n    Tbase diis_epsilon_ = 1e-1;\n    Tbase diis_threshold_ = 1e-4;\n    Tbase diis_diagonal_damping_ = 0.02;\n    Tbase diis_restart_factor_ = 1e-4;\n\n    Tbase optimal_damping_threshold_ = 1.0;\n\n    Tbase density_restart_factor_ = 1e-4;\n    int maximum_history_length_ = 10;\n    Tbase convergence_threshold_ = 1e-7;\n    std::string error_norm_ = \"rms\";\n\n    Tbase minimal_gradient_projection_ = 1e-4;\n    Tbase occupied_threshold_ = 1e-6;\n    Tbase initial_level_shift_ = 1.0;\n    Tbase level_shift_factor_ = 2.0;\n\n    /* Internal functions */\n    bool empty_block(size_t iblock) const {\n      // Check if Fock matrix has zero dimension\n      if(iblock&gt;=std::get&lt;0&gt;(orbital_history_[0]).first.size())\n        throw std::logic_error(\"Trying to check empty block for nonexistent index!\\n\");\n      return std::get&lt;1&gt;(orbital_history_[0]).second[iblock].n_elem == 0;\n    }\n\n    arma::Mat&lt;Torb&gt; get_density_matrix_block(size_t ihist, size_t iblock) const {\n      const auto orbitals = get_orbital_block(ihist, iblock);\n      const auto occupations = get_orbital_occupation_block(ihist, iblock);\n      return orbitals * arma::diagmat(occupations) * arma::trans(orbitals);\n    }\n\n    OrbitalBlock&lt;Torb&gt; get_orbital_block(size_t ihist, size_t iblock) const {\n      if(ihist&gt;=orbital_history_.size())\n        throw std::logic_error(\"Trying to access orbitals for nonexistent history member!\\n\");\n      if(iblock&gt;=std::get&lt;0&gt;(orbital_history_[ihist]).first.size())\n        throw std::logic_error(\"Trying to access orbitals for nonexistent block index!\\n\");\n      return std::get&lt;0&gt;(orbital_history_[ihist]).first[iblock];\n    }\n\n    OrbitalBlockOccupations&lt;Tbase&gt; get_orbital_occupation_block(size_t ihist, size_t iblock) const {\n      if(ihist&gt;=orbital_history_.size())\n        throw std::logic_error(\"Trying to access orbital occupations for nonexistent history member!\\n\");\n      if(iblock&gt;=std::get&lt;0&gt;(orbital_history_[ihist]).first.size())\n        throw std::logic_error(\"Trying to access orbital occupations for nonexistent block index!\\n\");\n      return std::get&lt;0&gt;(orbital_history_[ihist]).second[iblock];\n    }\n\n    Tbase get_lowest_energy_after_index(size_t index=0) const {\n      bool initialized = false;\n      Tbase lowest_energy;\n      for(size_t i=0;i&lt;orbital_history_.size();i++) {\n        if(get_index(i) &gt; index) {\n          if(not initialized) {\n            initialized=true;\n            lowest_energy = get_energy(i);\n          } else {\n            lowest_energy = std::min(lowest_energy, get_energy(i));\n          }\n        }\n      }\n      if(initialized)\n        return lowest_energy;\n      else {\n        print_history();\n        fflush(stdout);\n        std::ostringstream oss;\n        oss &lt;&lt; \"Did not find any entries with index greater than \" &lt;&lt; index &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n    }\n\n    size_t get_index(size_t ihist=0) const {\n      if(ihist&gt;=orbital_history_.size())\n        throw std::logic_error(\"Trying to access index for nonexistent history member!\\n\");\n      return std::get&lt;2&gt;(orbital_history_[ihist]);\n    }\n\n    size_t largest_index() const {\n      size_t index = get_index(0);\n      for(size_t i=1;i&lt;orbital_history_.size();i++) {\n        index = std::max(index, get_index(i));\n      }\n      return index;\n    }\n\n    arma::uvec matrix_dimension() const {\n      const auto &amp; fock = std::get&lt;1&gt;(orbital_history_[0]).second;\n      arma::uvec dim(fock.size());\n      for(size_t i=0;i&lt;fock.size();i++)\n        dim(i) = fock[i].n_cols;\n      return dim;\n    }\n\n    arma::Mat&lt;Torb&gt; get_fock_matrix_block(size_t ihist, size_t iblock) const {\n      return std::get&lt;1&gt;(orbital_history_[ihist]).second[iblock];\n    }\n\n    arma::Col&lt;Tbase&gt; vectorise(const arma::Mat&lt;Torb&gt; &amp; mat) const {\n      if constexpr (arma::is_real&lt;Torb&gt;::value) {\n        return arma::vectorise(mat);\n      } else {\n        return arma::join_cols(arma::vectorise(arma::real(mat)),arma::vectorise(arma::imag(mat)));\n      }\n    }\n\n    arma::Col&lt;Tbase&gt; vectorise(const std::vector&lt;arma::Mat&lt;Torb&gt;&gt; &amp; mat) const {\n      // Compute length of return vector\n      size_t N=0;\n\n      std::vector&lt;arma::Col&lt;Tbase&gt;&gt; vectors(mat.size());\n      for(size_t iblock=0;iblock&lt;mat.size();iblock++) {\n        if(mat[iblock].n_elem==0)\n          continue;\n        vectors[iblock]=vectorise(mat[iblock]);\n        N += vectors[iblock].n_elem;\n      }\n\n      arma::Col&lt;Tbase&gt; v(N,arma::fill::zeros);\n      size_t ioff=0;\n      for(size_t iblock=0;iblock&lt;vectors.size();iblock++) {\n        if(mat[iblock].n_elem==0)\n          continue;\n        v.subvec(ioff,ioff+vectors[iblock].n_elem-1)=vectors[iblock];\n        ioff += vectors[iblock].n_elem;\n      }\n\n      return v;\n    }\n\n    arma::Mat&lt;Torb&gt; matricise(const arma::Col&lt;Tbase&gt; &amp; vec, size_t nrows, size_t ncols) const {\n      if constexpr (arma::is_real&lt;Torb&gt;::value) {\n        if(vec.n_elem != nrows*ncols) {\n          std::ostringstream oss;\n          oss &lt;&lt; \"Matricise error: expected \" &lt;&lt; nrows*ncols &lt;&lt; \" elements for \" &lt;&lt; nrows &lt;&lt; \" x \" &lt;&lt; ncols &lt;&lt; \" real matrix, but got \" &lt;&lt; vec.n_elem &lt;&lt; \" instead!\\n\";\n          throw std::logic_error(oss.str());\n        }\n        return arma::Mat&lt;Torb&gt;(vec.memptr(), nrows, ncols);\n      } else {\n        if(vec.n_elem != 2*nrows*ncols) {\n          std::ostringstream oss;\n          oss &lt;&lt; \"Matricise error: expected \" &lt;&lt; 2*nrows*ncols &lt;&lt; \" elements for \" &lt;&lt; nrows &lt;&lt; \" x \" &lt;&lt; ncols &lt;&lt; \" complex matrix, but got \" &lt;&lt; vec.n_elem &lt;&lt; \" instead!\\n\";\n          throw std::logic_error(oss.str());\n        }\n\n        arma::Mat&lt;Tbase&gt; real(vec.memptr(), nrows, ncols);\n        arma::Mat&lt;Tbase&gt; imag(vec.memptr()+nrows*ncols, nrows, ncols);\n        arma::Mat&lt;Torb&gt; mat(real*std::complex&lt;Tbase&gt;(1.0,0.0) + imag*std::complex&lt;Tbase&gt;(0.0,1.0));\n        return mat;\n      }\n    }\n\n    std::vector&lt;arma::Mat&lt;Torb&gt;&gt; matricise(const arma::Col&lt;Tbase&gt; &amp; vec, const arma::uvec &amp; dim) const {\n      std::vector&lt;arma::Mat&lt;Torb&gt;&gt; mat(dim.n_elem);\n      size_t ioff = 0;\n      for(size_t iblock=0; iblock&lt;dim.n_elem; iblock++) {\n        if(dim(iblock)==0)\n          continue;\n        size_t size = dim(iblock)*dim(iblock);\n        if constexpr (not arma::is_real&lt;Torb&gt;::value) {\n          size *= 2;\n        }\n        mat[iblock] = matricise(vec.subvec(ioff, ioff+size-1), dim(iblock), dim(iblock));\n      }\n      return mat;\n    }\n\n    arma::Mat&lt;Torb&gt; diis_residual(size_t ihist, size_t iblock) const {\n      // Error is measured by FPS-SPF = FP - PF, since we have a unit metric.\n      auto F = get_fock_matrix_block(ihist, iblock);\n      auto P = get_density_matrix_block(ihist, iblock);\n      arma::Mat&lt;Torb&gt; PF = P*F;\n      PF -= arma::trans(PF);\n\n      // To make the L^infty error independent of the underlying basis\n      // set, we project the residual into the best orbitals we have\n      auto C = get_orbital_block(0, iblock);\n      PF = C.t() * PF * C;\n      return PF;\n    }\n\n    std::vector&lt;arma::Mat&lt;Torb&gt;&gt; diis_residual(size_t ihist) const {\n      std::vector&lt;arma::Mat&lt;Torb&gt;&gt; residuals(number_of_blocks_);\n      for(size_t iblock=0; iblock&lt;number_of_blocks_; iblock++) {\n        if(empty_block(iblock))\n          continue;\n        residuals[iblock] = diis_residual(ihist, iblock);\n      }\n      return residuals;\n    }\n\n    arma::Col&lt;Tbase&gt; diis_error_vector(size_t ihist, size_t iblock) const {\n      return vectorise(diis_residual(ihist, iblock));\n    }\n\n    arma::Col&lt;Tbase&gt; diis_error_vector(size_t ihist) const {\n      // Form error vectors\n      std::vector&lt;arma::Col&lt;Tbase&gt;&gt; error_vectors(number_of_blocks_);\n      for(size_t iblock = 0; iblock&lt;number_of_blocks_;iblock++) {\n        error_vectors[iblock] = diis_error_vector(ihist, iblock);\n        if(verbosity_&gt;=20)\n          printf(\"ihist %i block %i error vector norm %e\\n\", (int) ihist, (int) iblock, norm(error_vectors[iblock]));\n        if(verbosity_&gt;=30)\n          error_vectors[iblock].print();\n      }\n\n      // Compound error vector\n      size_t nelem = 0;\n      for(auto &amp; block: error_vectors)\n        nelem += block.size();\n\n      arma::Col&lt;Tbase&gt; return_vector(nelem);\n      size_t ioff=0;\n      for(auto &amp; block: error_vectors) {\n        if(block.size()&gt;0) {\n          return_vector.subvec(ioff,ioff+block.size()-1) = block;\n          ioff += block.size();\n        }\n      }\n      if(ioff!=nelem)\n        throw std::logic_error(\"Indexing error!\\n\");\n\n      return return_vector;\n    }\n\n    Tbase diis_error_matrix_element(size_t ihist, size_t jhist) const {\n      Tbase el=0.0;\n      for(size_t iblock=0; iblock&lt;number_of_blocks_; iblock++) {\n        if(empty_block(iblock))\n          continue;\n        arma::Col&lt;Tbase&gt; ei(diis_error_vector(ihist, iblock));\n        arma::Col&lt;Tbase&gt; ej(diis_error_vector(jhist, iblock));\n        el += arma::dot(ei,ej);\n      }\n      return el;\n    }\n\n    arma::Mat&lt;Tbase&gt; diis_error_matrix(const std::vector&lt;size_t&gt; &amp; mask) const {\n      // The error matrix is given by the orbital gradient dot products\n      const size_t N=mask.size();\n      arma::Mat&lt;Tbase&gt; B(N,N,arma::fill::zeros);\n\n      for(size_t ihist=0; ihist&lt;N; ihist++) {\n        for(size_t jhist=0; jhist&lt;=ihist; jhist++) {\n          B(ihist, jhist) = B(jhist, ihist) = diis_error_matrix_element(mask[ihist], mask[jhist]);\n        }\n      }\n      return B;\n    }\n\n    arma::Col&lt;Tbase&gt; diis_error_matrix_diagonal() const {\n      arma::Col&lt;Tbase&gt; B(orbital_history_.size(),arma::fill::zeros);\n      for(size_t ihist=0; ihist&lt;B.n_elem; ihist++) {\n        B(ihist) = diis_error_matrix_element(ihist, ihist);\n      }\n      return B;\n    }\n\n    arma::Mat&lt;Tbase&gt; diis_error_matrix() const {\n      std::vector&lt;size_t&gt; mask(orbital_history_.size());\n      for(size_t i=0;i&lt;mask.size();i++)\n        mask[i]=i;\n      return diis_error_matrix(mask);\n    }\n\n    arma::Col&lt;Tbase&gt; diis_weights() const {\n      // Only use reference points with error residuals that are sufficiently small\n      std::vector&lt;size_t&gt; history_mask(orbital_history_.size());\n      for(size_t i=0;i&lt;history_mask.size();i++)\n        history_mask[i]=i;\n      arma::Col&lt;Tbase&gt; residuals(history_mask.size());\n      for(size_t i=0;i&lt;residuals.size();i++)\n        residuals(i) = diis_error_matrix_element(history_mask[i], history_mask[i]);\n      Tbase min_residual = arma::min(residuals);\n      for(size_t i=history_mask.size()-1;i&lt;history_mask.size();i--)\n        // Criterion from Chupin et al, 2012\n        if(residuals(i)*diis_restart_factor_ &gt; min_residual)\n          history_mask.erase(history_mask.begin()+i);\n      size_t nrestart = orbital_history_.size()-history_mask.size();\n      if(verbosity_&gt;=10 and nrestart&gt;0)\n        printf(\"Removed %i entries corresponding to large DIIS errors\\n\", (int) nrestart);\n\n      // Set up the DIIS error matrix\n      const size_t N=history_mask.size();\n      arma::Mat&lt;Tbase&gt; B(N+1,N+1,arma::fill::value(-1.0));\n      B.submat(0,0,N-1,N-1)=diis_error_matrix(history_mask);\n      B(N,N)=0.0;\n\n      // Apply the diagonal damping\n      B.submat(0,0,N-1,N-1).diag() *= 1.0+diis_diagonal_damping_;\n\n      // To improve numerical conditioning, scale entries of error\n      // matrix such that the last diagonal element is one; Eckert et\n      // al, J. Comput. Chem 18. 1473-1483 (1997)\n      arma::Col&lt;Tbase&gt; Bdiag(arma::diagvec(B));\n      B.submat(0,0,N-1,N-1) /= arma::min(Bdiag.subvec(0,N-1));\n\n      // Right-hand side of equation is\n      arma::Col&lt;Tbase&gt; rh(N+1, arma::fill::zeros);\n      rh(N)=-1.0;\n\n      // Solve the equation\n      arma::Col&lt;Tbase&gt; diis_weights;\n      arma::solve(diis_weights, B, rh);\n      diis_weights=diis_weights.subvec(0,N-1);\n\n      // Pad to full space\n      arma::Col&lt;Tbase&gt; diis_weights_full(orbital_history_.size(),arma::fill::zeros);\n      for(size_t i=0;i&lt;history_mask.size();i++)\n        diis_weights_full[history_mask[i]] = diis_weights[i];\n\n      return diis_weights_full;\n    }\n    arma::Col&lt;Tbase&gt; aediis_weights(const arma::Col&lt;Tbase&gt; &amp; b, const arma::Mat&lt;Tbase&gt; &amp; A) const {\n      if(b.n_elem==1) {\n        // Nothing to optimize\n        return arma::ones&lt;arma::Col&lt;Tbase&gt;&gt;(b.n_elem);\n      }\n\n      // Parameters\n      const size_t max_iter = 1000000;\n      const Tbase df_tol = 1e-8;\n\n      // Function to evaluate function value\n      std::function&lt;Tbase(const arma::Col&lt;Tbase&gt; &amp; x)&gt; fx = [b, A](const arma::Col&lt;Tbase&gt; &amp; x) {\n        return 0.5*arma::as_scalar(x.t()*A*x) + arma::dot(b,x);\n      };\n\n      // Function to determine optimal step\n      std::function&lt;Tbase(const arma::Col&lt;Tbase&gt; &amp;, const arma::Col&lt;Tbase&gt; &amp;)&gt; optimal_step = [b, A](const arma::Col&lt;Tbase&gt; &amp; current_direction, const arma::Col&lt;Tbase&gt; &amp; x) {\n        return -(arma::as_scalar(current_direction.t()*A*x) + arma::dot(b,current_direction)) / (arma::as_scalar(current_direction.t()*A*current_direction));\n      };\n\n      std::vector&lt;arma::Col&lt;Tbase&gt;&gt; xguess;\n      // Center point\n      xguess.push_back(arma::Col&lt;Tbase&gt;(b.n_elem,arma::fill::value(1.0/b.n_elem)));\n      // \"Gauss\" points\n      for(size_t i=0;i&lt;b.n_elem;i++) {\n        arma::Col&lt;Tbase&gt; xtr(b.n_elem,arma::fill::value(1.0/(b.n_elem+2)));\n        xtr(i) *= 3;\n        xguess.push_back(xtr);\n      }\n      // End points\n      for(size_t i=0;i&lt;b.n_elem;i++) {\n        arma::Col&lt;Tbase&gt; xtr(b.n_elem,arma::fill::zeros);\n        xtr(i) = 1.0;\n        xguess.push_back(xtr);\n      }\n\n      // Find minimum\n      arma::vec yguess(xguess.size());\n      for(size_t i=0;i&lt;xguess.size();i++)\n        yguess[i] = fx(xguess[i]);\n\n      arma::uvec idx(arma::sort_index(yguess,\"ascend\"));\n      arma::Col&lt;Tbase&gt; x = xguess[idx[0]];\n      //x.t().print(\"Initial x\");\n\n      arma::Mat&lt;Tbase&gt; search_directions(b.n_elem,b.n_elem,arma::fill::eye);\n\n      auto current_point = fx(x);\n      auto old_x = x;\n\n      // Powell algorithm\n      for(size_t imacro=0; imacro&lt;max_iter; imacro++) {\n        Tbase curval(current_point);\n\n        for(size_t i=0; i&lt;b.n_elem; i++) {\n          arma::Col&lt;Tbase&gt; c_i(search_directions.col(i));\n          // x -&gt; (1-step)*x + step*c_i = x + step*(c_i-x)\n          Tbase step = optimal_step(c_i-x, x);\n          if(!std::isnormal(step))\n            continue;\n          //printf(\"Direction %i: optimal step %e\\n\",i,step);\n          if(step &gt; 0.0 and step &lt;= 1.0) {\n            auto new_point = fx(x+step*(c_i-x));\n            //printf(\"Direction %i: optimal step changes energy by %e\\n\",(int) i,new_point.first - current_point.first);\n            if(new_point &lt; current_point) {\n              x += step*(c_i-x);\n              current_point = new_point;\n            }\n          }\n        }\n\n        Tbase dE = current_point - curval;\n        //printf(\"Macroiteration %i changed energy by %e\\n\", imacro, dE);\n\n        // Update in x\n        arma::Col&lt;Tbase&gt; dx = x - old_x;\n\n        // Repeat line search along this direction\n        Tbase step = optimal_step(dx, x);\n        if(std::isnormal(step) and step &gt; 0.0 and step &lt;= 1.0) {\n          auto new_point = fx(x+step*dx);\n          if(new_point &lt; current_point) {\n            x += step*dx;\n            //printf(\"Line search along dx changes energy by %e\\n\", new_point-current_point);\n            current_point = new_point;\n            dE = current_point - curval;\n          }\n        }\n        old_x = x;\n\n        //x.t().print(\"x\");\n        if(dE &gt; -df_tol) {\n          if(verbosity_ &gt;= 10) {\n            printf(\"A/EDIIS weights converged in %i macroiterations\\n\",(int) imacro);\n            //x.t().print(\"xconv\");\n          }\n          break;\n        } else if(imacro==max_iter-1) {\n          if(verbosity_ &gt;= 10) {\n            printf(\"A/EDIIS weights did not converge in %i macroiterations, dE=%e\\n\", (int) imacro, dE);\n            //x.t().print(\"xfinal\");\n          }\n        }\n\n        /*\n        // Rotate search directions. Generate a random ordering of the columns\n        arma::uvec randperm(arma::randperm(search_directions.n_cols));\n        search_directions=search_directions.cols(randperm);\n        // Mix the vectors together\n        for(size_t i=0;i&lt;search_directions.n_cols;i++)\n          for(size_t j=0;j&lt;i;j++) {\n            arma::Col&lt;Tbase&gt; randu(1);\n            randu.randu();\n\n            arma::Col&lt;Tbase&gt; newi = (1-randu(0))*search_directions.col(i) + randu(0)*search_directions.col(j);\n            arma::Col&lt;Tbase&gt; newj = (1-randu(0))*search_directions.col(j) + randu(0)*search_directions.col(i);\n            search_directions.col(i) = newi;\n            search_directions.col(j) = newj;\n          }\n        */\n      }\n\n      // Handle the edge case where the last matrix has zero norm\n      if(x(0)==0.0) {\n        x.zeros();\n        x(0)=1.0;\n        // Reset search directions\n        search_directions.eye();\n        for(size_t i=0; i&lt;b.n_elem; i++) {\n          arma::Col&lt;Tbase&gt; c_i(search_directions.col(i));\n          // x -&gt; (1-step)*x + step*c_i = x + step*(c_i-x)\n          Tbase step = optimal_step(c_i-x, x);\n          if(!std::isnormal(step))\n            continue;\n          if(step &gt; 0.0 and step &lt; 1.0) {\n            auto new_point = fx(x+step*(c_i-x));\n            if(new_point &lt; current_point) {\n              x += step*(c_i-x);\n              current_point = new_point;\n            }\n          }\n        }\n        //x.t().print(\"Using suboptimal solution instead\");\n      }\n\n      //printf(\"Current energy %e\\n\",current_point);\n      //throw std::logic_error(\"Stop\");\n\n      return x;\n    }\n\n    arma::Col&lt;Tbase&gt; adiis_linear_term() const {\n      arma::Col&lt;Tbase&gt; ret(orbital_history_.size(),arma::fill::zeros);\n      for(size_t iblock=0;iblock&lt;number_of_blocks_;iblock++) {\n        if(empty_block(iblock))\n          continue;\n        const auto &amp; Dn = get_density_matrix_block(0, iblock);\n        const auto &amp; Fn = get_fock_matrix_block(0, iblock);\n        for(size_t ihist=0;ihist&lt;ret.size();ihist++) {\n          // D_i - D_n\n          arma::Mat&lt;Torb&gt; dD(get_density_matrix_block(ihist, iblock) - Dn);\n          ret(ihist) += 2.0*std::real(arma::trace(dD*Fn));\n        }\n      }\n      return ret;\n    }\n\n    arma::Col&lt;Tbase&gt; ediis_linear_term() const {\n      arma::Col&lt;Tbase&gt; ret(orbital_history_.size(),arma::fill::zeros);\n      for(size_t ihist=0;ihist&lt;orbital_history_.size();ihist++) {\n        ret(ihist) = get_energy(ihist);\n      }\n      return ret;\n    }\n\n    arma::Mat&lt;Tbase&gt; adiis_quadratic_term() const {\n      arma::Mat&lt;Tbase&gt; ret(orbital_history_.size(),orbital_history_.size(),arma::fill::zeros);\n      for(size_t iblock=0;iblock&lt;number_of_blocks_;iblock++) {\n        if(empty_block(iblock))\n          continue;\n        const auto &amp; Dn = get_density_matrix_block(0, iblock);\n        const auto &amp; Fn = get_fock_matrix_block(0, iblock);\n        for(size_t ihist=0;ihist&lt;orbital_history_.size();ihist++) {\n          for(size_t jhist=0;jhist&lt;orbital_history_.size();jhist++) {\n            // D_i - D_n\n            arma::Mat&lt;Torb&gt; dD(get_density_matrix_block(ihist, iblock) - Dn);\n            // F_j - F_n\n            arma::Mat&lt;Torb&gt; dF(get_fock_matrix_block(jhist, iblock) - Fn);\n            ret(ihist,jhist) += std::real(arma::trace(dD*dF));\n          }\n        }\n      }\n      // Only the symmetric part matters; we also multiply by two\n      // since we define the quadratic model as 0.5*x^T A x + b x\n      return ret+ret.t();\n    }\n\n    arma::Mat&lt;Tbase&gt; ediis_quadratic_term() const {\n      arma::Mat&lt;Tbase&gt; ret(orbital_history_.size(),orbital_history_.size(),arma::fill::zeros);\n      for(size_t iblock=0;iblock&lt;number_of_blocks_;iblock++) {\n        if(empty_block(iblock))\n          continue;\n        for(size_t ihist=0;ihist&lt;orbital_history_.size();ihist++) {\n          for(size_t jhist=0;jhist&lt;orbital_history_.size();jhist++) {\n            // D_i - D_j\n            arma::Mat&lt;Torb&gt; dD(get_density_matrix_block(ihist, iblock) - get_density_matrix_block(jhist, iblock));\n            // F_i - F_j\n            arma::Mat&lt;Torb&gt; dF(get_fock_matrix_block(ihist, iblock) - get_fock_matrix_block(jhist, iblock));\n            ret(ihist,jhist) -= std::real(arma::trace(dD*dF));\n          }\n        }\n      }\n      // Only the symmetric part matters; the factor 0.5 already\n      // exists in the base model\n      return 0.5*(ret+ret.t());\n    }\n\n    arma::Col&lt;Tbase&gt; adiis_weights() const {\n      return aediis_weights(adiis_linear_term(), adiis_quadratic_term());\n    }\n\n    arma::Col&lt;Tbase&gt; ediis_weights() const {\n      return aediis_weights(ediis_linear_term(), ediis_quadratic_term());\n    }\n\n    std::tuple&lt;arma::Col&lt;Tbase&gt;,std::string&gt; minimal_error_sampling_algorithm_weights(Tbase aediis_coeff) const {\n      // Form DIIS and ADIIS weights\n      arma::Col&lt;Tbase&gt; diis_w(diis_weights());\n      if(verbosity_&gt;=10) diis_w.t().print(\"DIIS weights\");\n      if(aediis_coeff == 0.0) {\n        std::string step = \"DIIS\";\n        return std::make_tuple(diis_w,step);\n      }\n\n      // Get various extrapolation weights\n      const size_t N = orbital_history_.size();\n      arma::Col&lt;Tbase&gt; adiis_w(adiis_weights());\n      if(verbosity_&gt;=10) adiis_w.t().print(\"ADIIS weights\");\n      arma::Col&lt;Tbase&gt; ediis_w(ediis_weights());\n      if(verbosity_&gt;=10) ediis_w.t().print(\"EDIIS weights\");\n\n      // Candidates\n      arma::Mat&lt;Tbase&gt; candidate_w(N, 2, arma::fill::zeros);\n      size_t icol=0;\n      candidate_w.col(icol++) = adiis_w;\n      candidate_w.col(icol++) = ediis_w;\n      const std::vector&lt;std::string&gt; weight_legend({\"ADIIS\", \"EDIIS\"});\n      std::string step;\n\n      arma::Col&lt;Tbase&gt; density_projections(candidate_w.n_cols, arma::fill::zeros);\n      for(size_t iw=0;iw&lt;candidate_w.n_cols;iw++) {\n        density_projections(iw) = density_projection(candidate_w.col(iw));\n      }\n      if(verbosity_&gt;=10)\n        density_projections.t().print(\"Density projections\");\n\n      arma::uword idx;\n      density_projections.max(idx);\n      if(verbosity_&gt;=10)\n        printf(\"Max density projection %e with %s weights\\n\",density_projections(idx),weight_legend[idx].c_str());\n\n      arma::Col&lt;Tbase&gt; aediis_w = candidate_w.col(idx);\n      arma::Col&lt;Tbase&gt; weights(aediis_coeff * aediis_w + (1.0 - aediis_coeff) * diis_w);\n      if(aediis_coeff == 1.0) {\n        step = weight_legend[idx];\n      } else {\n        step = weight_legend[idx] + \"+DIIS\";\n      }\n\n      return std::make_tuple(weights,step);\n    }\n\n    Tbase density_projection(const arma::Col&lt;Tbase&gt; &amp; weights) const {\n      // Get the extrapolated Fock matrix\n      auto fock(extrapolate_fock(weights));\n\n      // Reference calculation\n      const auto reference_orbitals = get_orbitals();\n      const auto reference_occupations = get_orbital_occupations();\n\n      // Diagonalize the extrapolated Fock matrix\n      auto diagonalized_fock = compute_orbitals(fock);\n      auto &amp; new_orbitals = diagonalized_fock.first;\n      auto &amp; new_orbital_energies = diagonalized_fock.second;\n\n      // Determine new occupations\n      auto new_occupations = update_occupations(new_orbital_energies);\n\n      return density_overlap(new_orbitals, new_occupations, reference_orbitals, reference_occupations);\n    }\n\n    Tbase occupation_difference(const OrbitalOccupations&lt;Tbase&gt; &amp; old_occ, const OrbitalOccupations&lt;Tbase&gt; &amp; new_occ) const {\n      Tbase diff = 0.0;\n      for(size_t iblock = 0; iblock&lt;old_occ.size(); iblock++) {\n        if(old_occ[iblock].n_elem==0)\n          continue;\n        size_t n = std::min(new_occ[iblock].n_elem, old_occ[iblock].n_elem);\n        diff += arma::sum(arma::abs(new_occ[iblock].subvec(0,n-1)-old_occ[iblock].subvec(0,n-1)));\n        if(new_occ[iblock].n_elem&gt;n)\n          diff += arma::sum(arma::abs(new_occ[iblock].subvec(n,new_occ[iblock].n_elem-1)));\n        else if(old_occ[iblock].n_elem&gt;n)\n          diff += arma::sum(arma::abs(old_occ[iblock].subvec(n,old_occ[iblock].n_elem-1)));\n      }\n\n      return diff;\n    }\n\n    FockMatrix&lt;Torb&gt; extrapolate_fock(const arma::Col&lt;Tbase&gt; &amp; weights) const {\n      if(weights.n_elem != orbital_history_.size()) {\n        std::ostringstream oss;\n        oss &lt;&lt; \"Inconsistent weights: \" &lt;&lt; weights.n_elem &lt;&lt; \" elements vs orbital history of size \" &lt;&lt; orbital_history_.size() &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n\n      // Form DIIS extrapolated Fock matrix\n      FockMatrix&lt;Torb&gt; extrapolated_fock(number_of_blocks_);\n      for(size_t iblock = 0; iblock &lt; extrapolated_fock.size(); iblock++) {\n        if(empty_block(iblock))\n          continue;\n        // Apply the DIIS weight\n        for(size_t ihist = 0; ihist &lt; orbital_history_.size(); ihist++) {\n          arma::Mat&lt;Torb&gt; block = weights(ihist) * get_fock_matrix_block(ihist, iblock);\n          if(ihist==0) {\n            extrapolated_fock[iblock] = block;\n          } else {\n            extrapolated_fock[iblock] += block;\n          }\n        }\n      }\n\n      return extrapolated_fock;\n    }\n\n    DensityMatrix&lt;Torb, Tbase&gt; extrapolate_density(const arma::Col&lt;Tbase&gt; &amp; weights) const {\n      if(weights.n_elem != orbital_history_.size()) {\n        std::ostringstream oss;\n        oss &lt;&lt; \"Inconsistent weights: \" &lt;&lt; weights.n_elem &lt;&lt; \" elements vs orbital history of size \" &lt;&lt; orbital_history_.size() &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n\n      // Form DIIS extrapolated density matrix\n      std::vector&lt;arma::Mat&lt;Torb&gt;&gt; orbitals(number_of_blocks_);\n      std::vector&lt;arma::Col&lt;Tbase&gt;&gt; occupations(number_of_blocks_);\n      for(size_t iblock = 0; iblock &lt; number_of_blocks_; iblock++) {\n        if(empty_block(iblock))\n          continue;\n\n        arma::Mat&lt;Torb&gt; dm_block;\n        for(size_t ihist = 0; ihist &lt; orbital_history_.size(); ihist++) {\n          arma::Mat&lt;Torb&gt; block = weights(ihist) * get_density_matrix_block(ihist, iblock);\n          if(ihist==0) {\n            dm_block = block;\n          } else {\n            dm_block += block;\n          }\n        }\n\n        // Flip the sign so that the orbitals come in increasing occupation\n        arma::eig_sym(occupations[iblock], orbitals[iblock], -dm_block);\n        occupations[iblock] *= -1;\n        // Zero out numerically zero occupations\n        arma::uvec zeroidx(arma::find(arma::abs(occupations[iblock])&lt;=10*maximum_occupation_(iblock)*std::numeric_limits&lt;Tbase&gt;::epsilon()));\n        occupations[iblock](zeroidx).zeros();\n      }\n\n      return std::make_pair(orbitals,occupations);\n    }\n\n    OrbitalOccupations&lt;Tbase&gt; determine_maximum_overlap_occupations(const OrbitalOccupations&lt;Tbase&gt; &amp; reference_occupations, const Orbitals&lt;Torb&gt; &amp; C_reference, const Orbitals&lt;Torb&gt; &amp; C_new) const {\n      OrbitalOccupations&lt;Tbase&gt; new_occupations(reference_occupations);\n      for(size_t iblock=0; iblock&lt;new_occupations.size(); iblock++) {\n        if(C_reference[iblock].n_elem == 0)\n          continue;\n        // Initialize\n        new_occupations[iblock].zeros();\n\n        // Magnitude of the overlap between the new orbitals and the reference ones\n        arma::Mat&lt;Tbase&gt; orbital_projections(arma::abs(C_new[iblock].t()*C_reference[iblock]));\n\n        // Occupy the orbitals in ascending energy, especially if there are unoccupied orbitals in-between\n        for(size_t iorb=0; iorb&lt;reference_occupations[iblock].n_elem; iorb++) {\n          // Projections for this orbital\n          auto projection = orbital_projections.col(iorb);\n          // Find the maximum index\n          auto maximal_projection_index = arma::index_max(projection);\n          auto maximal_projection = projection(maximal_projection_index);\n          // Store projection\n          new_occupations[iblock][maximal_projection_index] = reference_occupations[iblock](iorb);\n          // and reset the corresponding row so that the orbital can't be reused\n          orbital_projections.row(maximal_projection_index).zeros();\n\n          //printf(\"Symmetry %i: reference orbital %i with occupation %.3f matches new orbital %i with projection %e\\n\",(int) iblock, (int) iorb, reference_occupations[iblock](iorb), (int) maximal_projection_index, maximal_projection);\n        }\n      }\n\n      return new_occupations;\n    }\n\n    Tbase density_overlap(const Orbitals&lt;Torb&gt; &amp; lorb, const OrbitalOccupations&lt;Tbase&gt; &amp; locc, const Orbitals&lt;Torb&gt; &amp; rorb, const OrbitalOccupations&lt;Tbase&gt; &amp; rocc) const {\n      if(lorb.size() != rorb.size() or lorb.size() != locc.size() or lorb.size() != rocc.size())\n        throw std::logic_error(\"Inconsistent orbitals!\\n\");\n\n      Tbase ovl=0.0;\n      for(size_t iblock=0; iblock&lt;lorb.size(); iblock++) {\n        if(lorb[iblock].n_elem==0)\n          continue;\n        // Get orbital coefficients and occupations\n        const auto &amp; lC = lorb[iblock];\n        const auto &amp; lo = locc[iblock];\n        const auto &amp; rC = rorb[iblock];\n        const auto &amp; ro = rocc[iblock];\n        // Compute projection\n        arma::Mat&lt;Torb&gt; Pl(lC*arma::diagmat(lo)*lC.t());\n        arma::Mat&lt;Torb&gt; Pr(rC*arma::diagmat(ro)*rC.t());\n        ovl += std::real(arma::trace(Pl*Pr));\n      }\n      return ovl;\n    }\n\n    bool attempt_extrapolation(const arma::Col&lt;Tbase&gt; &amp; weights, bool density=false) {\n      // Get the extrapolated Fock matrix\n      if(not density) {\n        auto fock(extrapolate_fock(weights));\n        return attempt_fock(fock);\n      } else {\n        auto dm(extrapolate_density(weights));\n        return add_entry(std::make_pair(dm.first, dm.second));\n      }\n    }\n\n    bool attempt_fock(const FockMatrix&lt;Torb&gt; &amp; fock) {\n      // Diagonalize the Fock matrix\n      auto diagonalized_fock = compute_orbitals(fock);\n      auto new_orbitals = diagonalized_fock.first;\n      auto new_orbital_energies = diagonalized_fock.second;\n\n      // Determine new occupations\n      auto new_occupations = update_occupations(new_orbital_energies);\n\n      // Try out the new occupations\n      return add_entry(std::make_pair(new_orbitals, new_occupations));\n    }\n\n    bool optimal_damping_step() {\n      // Diagonalize the best Fock matrix\n      auto diagonalized_fock = compute_orbitals(std::get&lt;1&gt;(orbital_history_[0]).second);\n      auto new_orbitals = diagonalized_fock.first;\n      auto new_orbital_energies = diagonalized_fock.second;\n      // Determine new occupations\n      auto new_occupations = update_occupations(new_orbital_energies);\n\n      // Form the new density matrix\n      std::vector&lt;arma::Mat&lt;Torb&gt;&gt; dm_new(new_orbitals.size());\n      for(size_t iblock=0; iblock&lt;new_orbitals.size(); iblock++) {\n        if(new_orbitals[iblock].n_cols == 0)\n          continue;\n        dm_new[iblock] = new_orbitals[iblock] * arma::diagmat(new_occupations[iblock]) * arma::trans(new_orbitals[iblock]);\n      }\n\n      // Compute the energy gradient for each particle type for the density matrix mixing: P -&gt; (1-lambda)*Pcurrent + lambda*Pnew\n      size_t nparticles = number_of_blocks_per_particle_type_.n_elem;\n      arma::Col&lt;Tbase&gt; dEdlambda(nparticles, arma::fill::zeros);\n      for(size_t iparticle=0;iparticle&lt;nparticles;iparticle++) {\n        size_t block_offset = particle_block_offset(iparticle);\n        for(size_t iblock=block_offset;iblock&lt;block_offset+number_of_blocks_per_particle_type_(iparticle);iblock++) {\n          if(empty_block(iblock))\n            continue;\n          // Current density matrix\n          arma::Mat&lt;Torb&gt; fock_current(get_fock_matrix_block(0, iblock));\n          arma::Mat&lt;Torb&gt; dm_current(get_density_matrix_block(0, iblock));\n          dEdlambda(iparticle) += std::real(arma::trace(fock_current*(dm_new[iblock] - dm_current)));\n        }\n      }\n      if(verbosity_&gt;=10)\n        dEdlambda.t().print(\"Optimal damping: dE/dlambda\");\n\n      // Search direction is therefore\n      arma::Col&lt;Tbase&gt; search_direction = -dEdlambda;\n      // As we start the search from the current density matrix,\n      // lambda=0 at the outset and we set any negative directions as\n      // invalid\n      arma::uvec negative_indices = arma::find(search_direction &lt; 0.0);\n      if(negative_indices.n_elem)\n        search_direction(negative_indices).zeros();\n\n      arma::uvec valid_directions = arma::find(search_direction != 0);\n      if(valid_directions.n_elem==0) {\n        // No valid search directions!\n        return false;\n      }\n\n      // The resulting trial is therefore the step that takes us to\n      // the edge\n      arma::Col&lt;Tbase&gt; lambda_trial = search_direction/arma::max(search_direction);\n\n      // Helper function\n      std::function&lt;DensityMatrix&lt;Torb, Tbase&gt;(const arma::Col&lt;Tbase&gt; &amp;)&gt; interpolate_dm = [&amp;](const arma::Col&lt;Tbase&gt; &amp; step) {\n        Orbitals&lt;Torb&gt; new_orbs(number_of_blocks_);\n        OrbitalOccupations&lt;Tbase&gt; new_occs(number_of_blocks_);\n        for(size_t iparticle=0;iparticle&lt;nparticles;iparticle++) {\n          size_t block_offset = particle_block_offset(iparticle);\n          for(size_t iblock=block_offset;iblock&lt;block_offset+number_of_blocks_per_particle_type_(iparticle);iblock++) {\n            if(empty_block(iblock))\n              continue;\n            arma::Mat&lt;Torb&gt; dm_block((1-step(iparticle))*get_density_matrix_block(0, iblock) + step(iparticle)*dm_new[iblock]);\n            // Flip the sign so that the orbitals come in increasing occupation\n            arma::eig_sym(new_occs[iblock], new_orbs[iblock], -dm_block);\n            new_occs[iblock] *= -1;\n            // Zero out numerically zero occupations\n            arma::uvec zeroidx(arma::find(arma::abs(new_occs[iblock])&lt;=10*maximum_occupation_(iblock)*std::numeric_limits&lt;Tbase&gt;::epsilon()));\n            new_occs[iblock](zeroidx).zeros();\n          }\n        }\n        return std::make_pair(new_orbs, new_occs);\n      };\n\n      // Evaluate the energy with the trial density\n      if(add_entry(interpolate_dm(lambda_trial)))\n        // We already went down in energy, great!\n        return true;\n\n      // If we are here, we need to interpolate. Since we already\n      // handled the case that the full step decreased the energy, we\n      // know that the new step is the first in the stack since that\n      // is how it is sorted. Energies are\n      Tbase E0 = std::get&lt;1&gt;(orbital_history_[0]).first;\n      Tbase E1 = std::get&lt;1&gt;(orbital_history_[1]).first;\n      // and the gradients along the path are\n      Tbase dE0 = arma::dot(dEdlambda, lambda_trial);\n\n      arma::Col&lt;Tbase&gt; dEdlambda2(nparticles, arma::fill::zeros);\n      for(size_t iparticle=0;iparticle&lt;nparticles;iparticle++) {\n        size_t block_offset = particle_block_offset(iparticle);\n        for(size_t iblock=block_offset;iblock&lt;block_offset+number_of_blocks_per_particle_type_(iparticle);iblock++) {\n          if(empty_block(iblock))\n            continue;\n          // Current density matrix\n          arma::Mat&lt;Torb&gt; fock_new(get_fock_matrix_block(1, iblock));\n          arma::Mat&lt;Torb&gt; dm_current(get_density_matrix_block(0, iblock));\n          dEdlambda2(iparticle) += std::real(arma::trace(fock_new*(dm_new[iblock] - dm_current)));\n        }\n      }\n      Tbase dE1 = arma::dot(dEdlambda2, lambda_trial);\n\n      // Fit cubic\n      Tbase d = E0;\n      Tbase c = dE0;\n      Tbase b = -2*dE0 - 3*E0 + 3*E1 - dE1;\n      Tbase a = dE0 + 2*E0 - 2*E1 + dE1;\n      std::function&lt;Tbase(Tbase)&gt; eval_poly = [a,b,c,d](Tbase x) {\n        return (((a*x+b)*x+c)*x)+d;\n      };\n\n      // Convert to derivative\n      a *= 3;\n      b *= 2;\n      std::function&lt;Tbase(Tbase)&gt; eval_deriv = [a,b,c,d](Tbase x) {\n        return (a*x+b)*x+c;\n      };\n\n      // Solve roots\n      Tbase x1 = (-b - sqrt(b*b - 4*a*c))/(2*a);\n      Tbase x2 = (-b + sqrt(b*b - 4*a*c))/(2*a);\n      bool x1ok = x1 &gt; 0.0 and x1&lt;=1.0;\n      bool x2ok = x2 &gt; 0.0 and x2&lt;=1.0;\n\n      Tbase opt_step;\n      if(x1ok and x2ok) {\n        opt_step = eval_poly(x1) &lt; eval_poly(x2) ? x1 : x2;\n      } else if(x1ok) {\n        opt_step = x1;\n      } else if(x2ok) {\n        opt_step = x2;\n      } else {\n        // No allowable solution!\n        return false;\n      }\n      if(verbosity_&gt;=10)\n        printf(\"Optimal damping factor %e, predicted energy change %e\\n\",opt_step,eval_poly(opt_step)-eval_poly(0.0));\n\n      // Mix the density matrices\n      return add_entry(interpolate_dm(opt_step*lambda_trial));\n    }\n\n    void cleanup() {\n      arma::Col&lt;Tbase&gt; density_differences(orbital_history_.size()-1,arma::fill::zeros);\n      for(size_t ihist=1;ihist&lt;orbital_history_.size();ihist++) {\n        density_differences(ihist-1)=density_matrix_difference(ihist, 0);\n      }\n      if(verbosity_ &gt;= 10) {\n        density_differences.t().print(\"Density differences\");\n      } else if(verbosity_&gt;=5) {\n        printf(\"Density matrix difference %e between lowest-energy and newest entry\\n\",density_differences(0));\n      }\n\n      // Sort the differences\n      arma::uvec idx(arma::sort_index(density_differences,\"ascend\"));\n      // Pick the indices that don't satisfy the criterion\n      arma::uvec sub_idx(arma::find(density_restart_factor_*density_differences(idx) &gt; density_differences(idx(0))));\n      if(sub_idx.n_elem) {\n        idx=idx(sub_idx);\n        idx=arma::sort(idx,\"descend\");\n        if(verbosity_&gt;=10)\n          printf(\"Removing %i entries corresponding to large change in density matrix\\n\",(int) idx.n_elem);\n        for(auto ihistm1: idx) {\n          // Remember the off-by-one in the indices\n          orbital_history_.erase(orbital_history_.begin()+ihistm1+1);\n        }\n      }\n    }\n\n    std::vector&lt;OrbitalRotation&gt; degrees_of_freedom() const {\n      std::vector&lt;OrbitalRotation&gt; dofs;\n      // Reference calculation\n      const auto reference_occupations = get_orbital_occupations();\n\n      // List occupied-occupied rotations, in case some orbitals are not fully occupied\n      for(size_t iblock = 0; iblock &lt; reference_occupations.size(); iblock++) {\n        if(empty_block(iblock))\n          continue;\n        arma::uvec occupied_indices = arma::find(reference_occupations[iblock] &gt; 0.0);\n        for(size_t io1 = 0; io1 &lt; occupied_indices.size(); io1++)\n          for(size_t io2 = 0; io2 &lt; io1; io2++) {\n            auto o1 = occupied_indices[io1];\n            auto o2 = occupied_indices[io2];\n            if(reference_occupations[iblock][o1] != reference_occupations[iblock][o2])\n              dofs.push_back(std::make_tuple(iblock, o1, o2));\n          }\n      }\n\n      // List occupied-virtual rotations\n      for(size_t iblock = 0; iblock &lt; reference_occupations.size(); iblock++) {\n        if(empty_block(iblock))\n          continue;\n        // Find the occupied and virtual blocks\n        arma::uvec occupied_indices = arma::find(reference_occupations[iblock] &gt; 0.0);\n        arma::uvec virtual_indices = arma::find(reference_occupations[iblock] == 0.0);\n        for(auto o: occupied_indices)\n          for(auto v: virtual_indices)\n            dofs.push_back(std::make_tuple(iblock, o, v));\n      }\n\n      return dofs;\n    }\n\n    arma::Col&lt;Tbase&gt; orbital_gradient_vector() const {\n      // Get the degrees of freedom\n      auto dof_list = degrees_of_freedom();\n      arma::Col&lt;Tbase&gt; orb_grad;\n\n      if constexpr (arma::is_real&lt;Torb&gt;::value) {\n        orb_grad.zeros(dof_list.size());\n      } else {\n        orb_grad.zeros(2*dof_list.size());\n      }\n\n      // Extract the orbital gradient\n      for(size_t idof = 0; idof &lt; dof_list.size(); idof++) {\n        auto dof(dof_list[idof]);\n        auto iblock = std::get&lt;0&gt;(dof);\n        auto iorb = std::get&lt;1&gt;(dof);\n        auto jorb = std::get&lt;2&gt;(dof);\n        auto fock_block = get_fock_matrix_block(0, iblock);\n        auto orbital_block = get_orbital_block(0, iblock);\n        auto occ_block = get_orbital_occupation_block(0, iblock);\n\n        arma::Mat&lt;Torb&gt; fock_mo = orbital_block.t() * fock_block * orbital_block;\n        orb_grad(idof) = 2*std::real(fock_mo(iorb,jorb))*(occ_block(jorb)-occ_block(iorb));\n        if constexpr (!arma::is_real&lt;Torb&gt;::value) {\n          orb_grad(dof_list.size() + idof) = 2*std::imag(fock_mo(iorb,jorb))*(occ_block(jorb)-occ_block(iorb));\n        }\n      }\n\n      if(orb_grad.has_nan())\n        throw std::logic_error(\"Orbital gradient has NaNs\");\n\n      return orb_grad;\n    }\n\n    arma::Col&lt;Tbase&gt; diagonal_orbital_hessian() const {\n      // Get the degrees of freedom\n      auto dof_list = degrees_of_freedom();\n      arma::Col&lt;Tbase&gt; orb_hess;\n\n      if constexpr (arma::is_real&lt;Torb&gt;::value) {\n        orb_hess.zeros(dof_list.size());\n      } else {\n        orb_hess.zeros(2*dof_list.size());\n      }\n\n      // Extract the orbital hessient\n      for(size_t idof = 0; idof &lt; dof_list.size(); idof++) {\n        auto dof(dof_list[idof]);\n        auto iblock = std::get&lt;0&gt;(dof);\n        auto iorb = std::get&lt;1&gt;(dof);\n        auto jorb = std::get&lt;2&gt;(dof);\n        auto fock_block = get_fock_matrix_block(0, iblock);\n        auto orbital_block = get_orbital_block(0, iblock);\n        auto occ_block = get_orbital_occupation_block(0, iblock);\n\n        arma::Mat&lt;Torb&gt; fock_mo = orbital_block.t() * fock_block * orbital_block;\n        orb_hess(idof) = 2*std::real((fock_mo(iorb,iorb)-fock_mo(jorb,jorb))*(occ_block(jorb)-occ_block(iorb)));\n        if constexpr (!arma::is_real&lt;Torb&gt;::value) {\n          orb_hess(dof_list.size() + idof) = orb_hess(idof);\n        }\n      }\n      return orb_hess;\n    }\n\n    arma::Col&lt;Tbase&gt; precondition_search_direction(const arma::Col&lt;Tbase&gt; &amp; gradient, const arma::Col&lt;Tbase&gt; &amp; diagonal_hessian, Tbase shift=0.1) const {\n      if(gradient.n_elem != diagonal_hessian.n_elem)\n        throw std::logic_error(\"precondition_search_direction: gradient and diagonal hessian have different size!\\n\");\n\n      // Build positive definite diagonal Hessian\n      arma::Col&lt;Tbase&gt; positive_hessian(diagonal_hessian);\n      positive_hessian += (-arma::min(diagonal_hessian)+shift)*arma::ones&lt;arma::Col&lt;Tbase&gt;&gt;(positive_hessian.n_elem);\n\n      Tbase normalized_projection;\n      Tbase maximum_spread = arma::max(positive_hessian);\n      arma::Col&lt;Tbase&gt; preconditioned_direction;\n      while(true) {\n        // Normalize the largest values\n        arma::Col&lt;Tbase&gt; normalized_hessian(positive_hessian);\n        arma::uvec idx(arma::find(normalized_hessian&gt;maximum_spread));\n        normalized_hessian(idx) = maximum_spread*arma::ones&lt;arma::Col&lt;Tbase&gt;&gt;(idx.n_elem);\n\n        // and divide the gradient by its square root\n        preconditioned_direction = gradient/arma::sqrt(normalized_hessian);\n        if(preconditioned_direction.has_nan())\n          throw std::logic_error(\"Preconditioned search direction has NaNs\");\n\n        normalized_projection = arma::dot(preconditioned_direction, gradient) / std::sqrt(arma::norm(preconditioned_direction,2)*arma::norm(gradient, 2));\n        if(normalized_projection &gt;= minimal_gradient_projection_) {\n          return preconditioned_direction;\n        } else {\n          if(verbosity_&gt;=5) {\n            printf(\"Warning - projection of preconditioned search direction on negative gradient %e is too small, decreasing spread of Hessian values from %e by factor 10\\n\",normalized_projection,maximum_spread);\n          }\n          maximum_spread /= 10;\n        }\n      }\n    }\n\n    Orbitals&lt;Torb&gt; form_rotation_matrices(const arma::Col&lt;Tbase&gt; &amp; x) const {\n      const Orbitals&lt;Torb&gt; reference_orbitals(get_orbitals());\n\n      // Get the degrees of freedom\n      auto dof_list = degrees_of_freedom();\n      arma::Col&lt;Tbase&gt; orb_grad(dof_list.size());\n      // Sort them by symmetry\n      std::vector&lt;std::vector&lt;std::tuple&lt;arma::uword, arma::uword, size_t&gt;&gt;&gt; blocked_dof(reference_orbitals.size());\n      for(size_t idof=0; idof&lt;dof_list.size(); idof++) {\n        auto dof = dof_list[idof];\n        auto iblock = std::get&lt;0&gt;(dof);\n        auto iorb = std::get&lt;1&gt;(dof);\n        auto jorb = std::get&lt;2&gt;(dof);\n        blocked_dof[iblock].push_back(std::make_tuple(iorb,jorb,idof));\n      }\n\n      // Form the rotation matrices\n      Orbitals&lt;Torb&gt; kappa(reference_orbitals.size());\n      for(size_t iblock=0; iblock &lt; reference_orbitals.size(); iblock++) {\n        if(empty_block(iblock))\n          continue;\n        // Collect the rotation parameters\n        kappa[iblock].zeros(reference_orbitals[iblock].n_cols, reference_orbitals[iblock].n_cols);\n        for(auto dof: blocked_dof[iblock]) {\n          auto iorb = std::get&lt;0&gt;(dof);\n          auto jorb = std::get&lt;1&gt;(dof);\n          auto idof = std::get&lt;2&gt;(dof);\n          kappa[iblock](iorb,jorb) = x(idof);\n        }\n        // imaginary parameters\n        if constexpr (!arma::is_real&lt;Torb&gt;::value) {\n          for(auto dof: blocked_dof[iblock]) {\n            auto iorb = std::get&lt;0&gt;(dof);\n            auto jorb = std::get&lt;1&gt;(dof);\n            auto idof = std::get&lt;2&gt;(dof);\n            kappa[iblock](iorb,jorb) += Torb(0.0,x(dof_list.size()+idof));\n          }\n        }\n        // Antisymmetrize\n        kappa[iblock] -= arma::trans(kappa[iblock]);\n      }\n\n      return kappa;\n    }\n\n    Tbase maximum_rotation_step(const arma::Col&lt;Tbase&gt; &amp; x) const {\n      // Get the rotation matrices\n      auto kappa(form_rotation_matrices(x));\n\n      Tbase maximum_step = std::numeric_limits&lt;Tbase&gt;::max();\n      for(size_t iblock=0; iblock &lt; kappa.size(); iblock++) {\n        if(kappa[iblock].n_elem==0)\n          continue;\n        arma::Col&lt;Tbase&gt; eval;\n        arma::Mat&lt;std::complex&lt;Tbase&gt;&gt; evec;\n        arma::Mat&lt;std::complex&lt;Tbase&gt;&gt; kappa_imag(kappa[iblock]*std::complex&lt;Tbase&gt;(0.0,-1.0));\n        arma::eig_sym(eval, evec, kappa_imag);\n\n        // Assume objective function is 4th order in orbitals\n        Tbase block_maximum = 0.5*M_PI/arma::max(arma::abs(eval));\n        // The maximum allowed step is determined as the minimum of the block-wise steps\n        maximum_step = std::min(maximum_step, block_maximum);\n      }\n\n      return maximum_step;\n    }\n\n    Orbitals&lt;Torb&gt; rotate_orbitals(const arma::Col&lt;Tbase&gt; &amp; x) const {\n      auto kappa(form_rotation_matrices(x));\n\n      // Rotate the orbitals\n      Orbitals&lt;Torb&gt; new_orbitals(get_orbitals());\n      for(size_t iblock=0; iblock &lt; new_orbitals.size(); iblock++) {\n        if(empty_block(iblock))\n          continue;\n\n        // Exponentiated kappa\n        arma::Mat&lt;Torb&gt; expkappa;\n\n#if 0\n        expkappa = arma::expmat(kappa[iblock]);\n#else\n        // Do eigendecomposition\n        arma::Col&lt;Tbase&gt; eval;\n        arma::Mat&lt;std::complex&lt;Tbase&gt;&gt; evec;\n        arma::Mat&lt;std::complex&lt;Tbase&gt;&gt; kappa_imag(kappa[iblock]*std::complex&lt;Tbase&gt;(0.0,-1.0));\n        arma::eig_sym(eval, evec, kappa_imag);\n        // Exponentiate\n        arma::Mat&lt;std::complex&lt;Tbase&gt;&gt; expkappa_imag(evec*arma::diagmat(arma::exp(eval*std::complex&lt;Tbase&gt;(0.0,1.0)))*evec.t());\n        if constexpr (arma::is_real&lt;Torb&gt;::value) {\n          expkappa = arma::real(expkappa_imag);\n        } else {\n          expkappa = expkappa_imag;\n        }\n#endif\n\n        // Do the rotation\n        new_orbitals[iblock] = new_orbitals[iblock]*expkappa;\n      }\n\n      return new_orbitals;\n    }\n    OrbitalHistoryEntry&lt;Torb, Tbase&gt; make_history_entry(const DensityMatrix&lt;Torb, Tbase&gt; &amp; density_matrix, const FockBuilderReturn&lt;Torb, Tbase&gt; &amp; fock) const {\n      static size_t index=0;\n      return std::make_tuple(density_matrix, fock, index++);\n    }\n    OrbitalHistoryEntry&lt;Torb, Tbase&gt; evaluate_rotation(const arma::Col&lt;Tbase&gt; &amp; x) {\n      // Rotate orbitals\n      auto new_orbitals(rotate_orbitals(x));\n      // Compute the Fock matrix\n      auto reference_occupations = get_orbital_occupations();\n\n      auto density_matrix = std::make_pair(new_orbitals, reference_occupations);\n      auto fock = fock_builder_(density_matrix);\n      number_of_fock_evaluations_++;\n      return make_history_entry(density_matrix, fock);\n    }\n    void level_shifting_step() {\n      Tbase level_shift = initial_level_shift_;\n      Tbase reference_energy = get_energy();\n      size_t start_index = largest_index();\n\n      if(verbosity_ &gt;= 5)\n        printf(\"Entering level shifting code, reference energy %e\\n\",reference_energy);\n\n      // Get Fock matrix\n      FockMatrix&lt;Torb&gt; fock = get_fock_matrix();\n      // Form level shift matrix\n      FockMatrix&lt;Torb&gt; shifted_fock;\n\n      for(size_t ishift=0; ishift &lt; 50; ishift++) {\n        // Shift virtual orbitals up in energy. In practice, scale\n        // the level shift by the fraction of unoccupied character,\n        // so that SOMOs get half the shift\n        shifted_fock = fock;\n        for(size_t iblock=0; iblock&lt;fock.size(); iblock++) {\n          if(empty_block(iblock))\n            continue;\n          arma::Col&lt;Tbase&gt; fractional_occupations(get_orbital_occupation_block(0, iblock)/maximum_occupation_(iblock));\n          fractional_occupations = arma::ones&lt;arma::Col&lt;Tbase&gt;&gt;(fractional_occupations.n_elem) - fractional_occupations;\n          arma::Mat&lt;Torb&gt; orbitals(get_orbital_block(0, iblock));\n\n          shifted_fock[iblock] += level_shift *(orbitals * arma::diagmat(fractional_occupations) * orbitals.t());\n        }\n\n        // Add new Fock matrix\n        attempt_fock(shifted_fock);\n        Tbase best_energy = get_lowest_energy_after_index(start_index);\n        if(verbosity_ &gt;= 5)\n          printf(\"Level shift iteration %i: shift %e energy change % e\\n\", ishift, level_shift, best_energy-reference_energy);\n\n        if(best_energy &gt; reference_energy) {\n          // Energy did not decrease; increase level shift\n          level_shift *= level_shift_factor_;\n          continue;\n        } else {\n          return;\n        }\n      }\n    }\n    void steepest_descent_step() {\n      // Reference energy\n      auto reference_energy = get_energy();\n\n      // Get the orbital gradient\n      auto gradient = orbital_gradient_vector();\n      // and the diagonal Hessian\n      auto diagonal_hessian = diagonal_orbital_hessian();\n\n      // Precondition search direction\n      auto search_direction = precondition_search_direction(-gradient, diagonal_hessian);\n\n      // Ensure that the search direction is down-hill\n      if(arma::dot(search_direction, gradient) &gt;= 0.0) {\n        throw std::logic_error(\"Search direction is not down-hill?\\n\");\n      }\n\n      // Helper to evaluate steps\n      std::function&lt;Tbase(Tbase)&gt; evaluate_step = [this, search_direction](Tbase length){\n        Tbase reference_energy(get_energy());\n        if(length==0.0)\n          // We just get the reference energy\n          return reference_energy;\n        auto p(search_direction*length);\n        auto entry = evaluate_rotation(p);\n        if(length!=0.0)\n          add_entry(std::get&lt;0&gt;(entry), std::get&lt;1&gt;(entry));\n        if(verbosity_&gt;=5)\n          printf(\"Evaluated step %e with energy %.10f change from reference %e\\n\", length, std::get&lt;1&gt;(entry).first, std::get&lt;1&gt;(entry).first-reference_energy);\n        return std::get&lt;1&gt;(entry).first;\n      };\n      std::function&lt;Tbase(Tbase)&gt; scan_step = [this, search_direction](Tbase length){\n        auto p(search_direction*length);\n        auto entry = evaluate_rotation(p);\n        return std::get&lt;1&gt;(entry).first;\n      };\n\n      // Determine the maximal step size\n      Tbase Tmu = maximum_rotation_step(search_direction);\n      // This step is a whole quasiperiod. Since we are going downhill,\n      // the minimum would be at Tmu/4. However, since the function is\n      // nonlinear, the minimum is found at a shorter distance. We use\n      // Tmu/5 as the trial step\n      auto step = Tmu/5.0;\n\n      // Current energy\n      auto initial_energy(evaluate_step(0.0));\n\n      static int iter=0;\n      arma::Col&lt;Tbase&gt; ttest(arma::linspace&lt;arma::Col&lt;Tbase&gt;&gt;(0.0,1.0,51)*Tmu);\n\n#if 0\n      arma::Mat&lt;Tbase&gt; data(ttest.n_elem, 2);\n      data.col(0)=ttest;\n      for(size_t i=0;i&lt;ttest.n_elem;i++)\n        data(i,1) = scan_step(ttest(i));\n      std::ostringstream oss;\n      oss &lt;&lt; \"scan_\" &lt;&lt; iter &lt;&lt; \".dat\";\n      data.save(oss.str(),arma::raw_ascii);\n      iter++;\n\n      // Test the routines\n      auto dof_list = degrees_of_freedom();\n      auto g(search_direction);\n      for(size_t i=0;i&lt;g.n_elem;i++) {\n        auto dof(dof_list[i]);\n        auto iblock = std::get&lt;0&gt;(dof);\n        auto iorb = std::get&lt;1&gt;(dof);\n        auto jorb = std::get&lt;2&gt;(dof);\n\n        Tbase hh=cbrt(DBL_EPSILON);\n        //Tbase hh=1e-10;\n\n        std::function&lt;Tbase(Tbase)&gt; eval = [this, search_direction, i](Tbase xi){\n          auto p(search_direction);\n          p.zeros();\n          p(i) = xi;\n          auto entry = evaluate_rotation(p);\n          return std::get&lt;1&gt;(entry).first;\n        };\n\n        auto E2mi = eval(-2*hh);\n        auto Emi = eval(-hh);\n        auto Ei = eval(hh);\n        auto E2i = eval(2*hh);\n\n        Tbase twop = (Ei-initial_energy)/hh;\n        Tbase threep = (Ei-Emi)/(2*hh);\n        printf(\"i=%i twop=%e threep=%e\\n\",i,twop,threep);\n\n        Tbase h2diff = (Ei - 2*initial_energy + Emi)/(hh*hh);\n        Tbase h4diff = (-1/12.0*E2mi +4.0/3.0*Emi - 5.0/2.0*initial_energy + 4.0/3.0*Ei -1./12.0*E2i)/(hh*hh);\n\n        g(i) = threep;\n        printf(\"g(%3i), block %i orbitals %i-%i, % e vs % e (two-point   % e) difference % e ratio % e\\n\",i,iblock, iorb, jorb, gradient(i),g(i),twop,gradient(i)-g(i),gradient(i)/g(i));\n        printf(\"h(%3i), block %i orbitals %i-%i, % e vs % e (three-point % e) difference % e ratio % e\\n\",i,iblock, iorb, jorb, diagonal_hessian(i),h4diff,h2diff,diagonal_hessian(i)-h4diff,diagonal_hessian(i)/h4diff);\n        fflush(stdout);\n      }\n      gradient.print(\"Analytic gradient\");\n      g.print(\"Finite difference gradient\");\n      (gradient/g).print(\"Ratio\");\n#endif\n\n      // Line search\n      bool search_success = false;\n      for(size_t itrial=0; itrial&lt;10; itrial++) {\n        if(verbosity_&gt;=5) {\n          printf(\"Trial iteration %i\\n\",itrial);\n          fflush(stdout);\n        }\n\n        // Evaluate the energy\n        auto trial_energy = evaluate_step(step);\n        if(trial_energy &lt; initial_energy) {\n          // We already decreased the energy! Don't do anything more,\n          // because our expansion point has already changed and going\n          // further would make no sense.\n          search_success = true;\n          break;\n        }\n\n        // Now we can fit a second order polynomial y = a x^2 + dE x +\n        // initial_energy to our data: we know the initial value and the slope, and\n        // the observed value.\n        auto dE = arma::dot(gradient, search_direction);\n        auto a = (trial_energy - dE*step - initial_energy)/(step*step);\n\n        if(verbosity_&gt;=10) {\n          printf(\"a = %e\\n\",a);\n          fflush(stdout);\n        }\n\n        // To be realistic, the parabola should open up\n        auto fit_okay = std::isnormal(a) and a&gt;0.0;\n        if(fit_okay) {\n          auto predicted_step = -dE/(2.0*a);\n          auto predicted_energy = a * predicted_step*predicted_step + dE*predicted_step + initial_energy;\n\n          // To be reliable, the predicted optimal step should also be\n          // in [0.0, step]\n          if(predicted_step &lt; 0.0 or predicted_step &gt; step)\n            fit_okay = false;\n          if(predicted_step == step)\n            // Nothing to do since the step was already evaluated!\n            break;\n\n          if(fit_okay) {\n            auto observed_energy = evaluate_step(predicted_step);\n            if(verbosity_&gt;=5) {\n              printf(\"Predicted energy % .10f observed energy % .10f difference %e\\n\", predicted_energy, observed_energy,predicted_energy-observed_energy);\n              fflush(stdout);\n            }\n\n            if(observed_energy &lt; initial_energy) {\n              search_success=true;\n              break;\n            } else {\n              if(verbosity_&gt;=5) {\n                printf(\"Error: energy did not decrease in line search! Decreasing trial step size\\n\");\n                fflush(stdout);\n              }\n              step = std::max(10.0*predicted_step, step/2.0);\n            }\n          }\n        }\n      }\n      if(not search_success) {\n        arma::Col&lt;Tbase&gt; ttest(arma::logspace&lt;arma::Col&lt;Tbase&gt;&gt;(-16,4,101)*Tmu);\n        arma::Mat&lt;Tbase&gt; data(ttest.n_elem, 2);\n        data.col(0)=ttest/Tmu;\n        for(size_t i=0;i&lt;ttest.n_elem;i++) {\n          data(i,1) = scan_step(ttest(i));\n          printf(\"%e %e % e % e\\n\",data(i,0),data(i,0)*Tmu,data(i,1),data(i,1)-get_energy());\n          fflush(stdout);\n        }\n        data.save(\"linesearch.dat\",arma::raw_ascii);\n        throw std::runtime_error(\"Failed to find suitable step size.\\n\");\n      }\n    }\n\n    std::vector&lt;arma::uvec&gt; occupied_orbitals(const OrbitalOccupations&lt;Tbase&gt; &amp; occupations) {\n      std::vector&lt;arma::uvec&gt; occ_idx(occupations.size());\n      for(size_t l=0;l&lt;occupations.size();l++) {\n        occ_idx[l]=arma::find(occupations[l]&gt;=occupied_threshold_);\n      }\n      return occ_idx;\n    }\n\n    std::vector&lt;arma::uvec&gt; unoccupied_orbitals(const OrbitalOccupations&lt;Tbase&gt; &amp; occupations) {\n      std::vector&lt;arma::uvec&gt; virt_idx(occupations.size());\n      for(size_t l=0;l&lt;occupations.size();l++) {\n        virt_idx[l]=arma::find(occupations[l]&lt;occupied_threshold_);\n      }\n      return virt_idx;\n    }\n\n  public:\n    SCFSolver(const arma::uvec &amp; number_of_blocks_per_particle_type, const arma::Col&lt;Tbase&gt; &amp; maximum_occupation, const arma::Col&lt;Tbase&gt; &amp; number_of_particles, const FockBuilder&lt;Torb, Tbase&gt; &amp; fock_builder, const std::vector&lt;std::string&gt; &amp; block_descriptions) : number_of_blocks_per_particle_type_(number_of_blocks_per_particle_type), maximum_occupation_(maximum_occupation), number_of_particles_(number_of_particles), fock_builder_(fock_builder), block_descriptions_(block_descriptions), frozen_occupations_(false), verbosity_(5) {\n      // Run sanity checks\n      number_of_blocks_ = arma::sum(number_of_blocks_per_particle_type_);\n      if(maximum_occupation_.size() != number_of_blocks_) {\n        std::ostringstream oss;\n        oss &lt;&lt; \"Vector of maximum occupation is not of expected length! Got \" &lt;&lt; maximum_occupation_.size() &lt;&lt; \" elements, expected \" &lt;&lt; number_of_blocks_ &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n      if(number_of_particles_.size() != number_of_blocks_per_particle_type_.size()) {\n        std::ostringstream oss;\n        oss &lt;&lt; \"Vector of number of particles is not of expected length! Got \" &lt;&lt; number_of_particles_.size() &lt;&lt; \" elements, expected \" &lt;&lt; number_of_blocks_per_particle_type_ &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n      if(block_descriptions_.size() != number_of_blocks_) {\n        std::ostringstream oss;\n        oss &lt;&lt; \"Vector of block descriptions is not of expected length! Got \" &lt;&lt; block_descriptions_.size() &lt;&lt; \" elements, expected \" &lt;&lt; number_of_blocks_ &lt;&lt; \"!\\n\";\n        throw std::logic_error(oss.str());\n      }\n    }\n\n    void initialize_with_fock(const FockMatrix&lt;Torb&gt; &amp; fock_guess) {\n      if(fock_guess.size() != number_of_blocks_)\n        throw std::logic_error(\"Fed in Fock matrix does not have the required number of blocks!\\n\");\n\n      // Compute orbitals\n      auto diagonalized_fock = compute_orbitals(fock_guess);\n      const auto &amp; orbitals = diagonalized_fock.first;\n      const auto &amp; orbital_energies = diagonalized_fock.second;\n\n      // Compute the occupations\n      orbital_occupations_ = update_occupations(orbital_energies);\n      // This routine handles the rest\n      initialize_with_orbitals(orbitals, orbital_occupations_);\n    }\n\n    void initialize_with_orbitals(const Orbitals&lt;Torb&gt; &amp; orbitals, const OrbitalOccupations&lt;Tbase&gt; &amp; orbital_occupations) {\n      if(orbitals.size() != orbital_occupations.size())\n        throw std::logic_error(\"Fed in orbitals and orbital occupations are not consistent!\\n\");\n      if(orbitals.size() != number_of_blocks_)\n        throw std::logic_error(\"Fed in orbitals and orbital occupations do not have the required number of blocks!\\n\");\n      orbital_history_.clear();\n\n      // Reset number of evaluations\n      number_of_fock_evaluations_ = 0;\n      add_entry(std::make_pair(orbitals, orbital_occupations));\n\n      // Check that dimensions are consistent\n      bool consistent=true;\n      for(size_t iblock=0;iblock&lt;number_of_blocks_;iblock++) {\n        if(empty_block(iblock))\n          continue;\n        if(get_orbital_block(0,iblock).n_cols != get_fock_matrix_block(0,iblock).n_cols) {\n          printf(\"get_orbital_block(0,iblock).n_cols=%i != get_fock_matrix_block(0,iblock).n_cols)=%i\\n\",(int) get_orbital_block(0,iblock).n_cols,(int) get_fock_matrix_block(0,iblock).n_cols);\n          consistent=false;\n        }\n        if(get_orbital_occupation_block(0,iblock).n_elem != get_fock_matrix_block(0,iblock).n_cols) {\n          if(verbosity_&gt;=10)\n            printf(\"get_orbital_occupation_block(0,iblock).n_elem=%i != get_fock_matrix_block(0,iblock).n_cols=%i\\n\",(int) get_orbital_occupation_block(0,iblock).n_elem,(int) get_fock_matrix_block(0,iblock).n_cols);\n          consistent=false;\n        }\n      }\n      // If they are not consistent (e.g. when a read-in guess has been used)\n      if(not consistent) {\n        if(verbosity_&gt;=5)\n          printf(\"Fed-in orbitals are not consistent with Fock matrix, recomputing orbitals\\n\");\n\n        // Diagonalize the Fock matrix we just computed\n        auto new_orbitals = compute_orbitals(get_fock_matrix());\n        // Determine new occupations\n        auto new_occupations = update_occupations(new_orbitals.second);\n\n        // Clear out the old history\n        orbital_history_.clear();\n        // and add the new entry\n        add_entry(std::make_pair(new_orbitals.first, new_occupations));\n      }\n    }\n\n    void fixed_number_of_particles_per_block(const arma::Col&lt;Tbase&gt; &amp; number_of_particles_per_block) {\n      fixed_number_of_particles_per_block_ = number_of_particles_per_block;\n    }\n\n    bool frozen_occupations() const {\n      return frozen_occupations_;\n    }\n\n    void frozen_occupations(bool frozen) {\n      frozen_occupations_ = frozen;\n    }\n\n    int verbosity() const {\n      return verbosity_;\n    }\n\n    void verbosity(int verbosity) {\n      verbosity_ = verbosity;\n    }\n\n    Tbase convergence_threshold() const {\n      return convergence_threshold_;\n    }\n\n    void convergence_threshold(Tbase convergence_threshold) {\n      convergence_threshold_ = convergence_threshold;\n    }\n\n    Tbase get_energy(size_t ihist=0) const {\n      if(ihist&gt;orbital_history_.size())\n        throw std::logic_error(\"Invalid entry!\\n\");\n      return std::get&lt;1&gt;(orbital_history_[ihist]).first;\n    }\n\n\n    Tbase density_matrix_difference(size_t ihist, size_t jhist) {\n      Tbase diff_norm = 0.0;\n      for(size_t iblock=0;iblock&lt;number_of_blocks_;iblock++) {\n        if(empty_block(iblock))\n          continue;\n        diff_norm += norm(vectorise(get_density_matrix_block(ihist, iblock)-get_density_matrix_block(jhist, iblock)));\n      }\n      return diff_norm;\n    }\n\n    std::string error_norm() const {\n      return error_norm_;\n    }\n\n    Tbase norm(const arma::Mat&lt;Tbase&gt; &amp; mat, std::string norm=\"\") const {\n      if(norm == \"\")\n        norm=error_norm_;\n      if(norm == \"rms\") {\n        // rms isn't implemented in Armadillo for some reason\n        if(mat.n_elem == 0)\n          return 0;\n        return arma::norm(mat,\"fro\")/std::sqrt(1.0*mat.n_elem);\n      } else {\n        return arma::norm(mat, norm.c_str());\n      }\n    }\n\n    void error_norm(const std::string &amp; error_norm) {\n      // Set the norm\n      error_norm_ = error_norm;\n      // and check that it is a valid option\n      arma::Col&lt;Tbase&gt; test(1,arma::fill::ones);\n      (void) norm(test);\n    }\n\n    size_t maximum_iterations() const {\n      return maximum_iterations_;\n    }\n\n    void maximum_iterations(size_t maxit) {\n      maximum_iterations_ = maxit;\n    }\n\n    Tbase diis_epsilon() const {\n      return diis_epsilon_;\n    }\n\n    void diis_epsilon(Tbase eps) {\n      diis_epsilon_ = eps;\n    }\n\n    Tbase diis_threshold() const {\n      return diis_threshold_;\n    }\n\n    void diis_threshold(Tbase eps) {\n      diis_threshold_ = eps;\n    }\n\n    Tbase diis_diagonal_damping() const {\n      return diis_diagonal_damping_;\n    }\n\n    void diis_diagonal_damping(Tbase eps) {\n      diis_diagonal_damping_ = eps;\n    }\n\n    Tbase diis_restart_factor() const {\n      return diis_restart_factor_;\n    }\n\n    void diis_restart_factor(Tbase eps) {\n      diis_restart_factor_ = eps;\n    }\n\n    Tbase optimal_damping_threshold() const {\n      return optimal_damping_threshold_;\n    }\n\n    void optimal_damping_threshold(Tbase eps) {\n      optimal_damping_threshold_ = eps;\n    }\n\n    int maximum_history_length() const {\n      return maximum_history_length_;\n    }\n\n    void maximum_history_length(int maximum_history_length) {\n      maximum_history_length_ = maximum_history_length;\n    }\n\n    bool add_entry(const DensityMatrix&lt;Torb, Tbase&gt; &amp; density) {\n      // Compute the Fock matrix\n      auto fock = fock_builder_(density);\n      number_of_fock_evaluations_++;\n\n      if(verbosity_&gt;=5) {\n        auto reference_energy = orbital_history_.size()&gt;0 ? get_energy() : 0.0;\n        printf(\"Evaluated energy % .10f (change from lowest %e)\\n\", fock.first, fock.first-reference_energy);\n      }\n      return add_entry(density, fock);\n    }\n\n    bool add_entry(const DensityMatrix&lt;Torb, Tbase&gt; &amp; density, const FockBuilderReturn&lt;Torb, Tbase&gt; &amp; fock) {\n      // Make a pair\n      orbital_history_.push_back(make_history_entry(density, fock));\n\n      if(std::isnan(fock.first)) {\n        throw std::logic_error(\"Got NaN total energy!\\n\");\n      }\n      if(std::isinf(fock.first)) {\n        throw std::logic_error(\"Got +-infinite total energy!\\n\");\n      }\n      for(size_t iblock=0;iblock&lt;fock.second.size();iblock++) {\n        if(fock.second[iblock].n_rows==0)\n          continue;\n        if(fock.second[iblock].has_nan()) {\n          throw std::logic_error(\"Got NaN in Fock matrix!\\n\");\n        }\n        if(fock.second[iblock].has_inf()) {\n          throw std::logic_error(\"Got +-infinity in Fock matrix!\\n\");\n        }\n      }\n\n      if(orbital_history_.size()==1)\n        // First try is a success by definition\n        return true;\n      else {\n        // Otherwise we have to check if we lowered the energy\n        Tbase new_energy = fock.first;\n        Tbase old_energy = get_energy();\n        bool return_value = new_energy &lt; old_energy;\n\n        // Now, we first sort the stack in increasing energy to get\n        // the lowest energy solution at the beginning\n        std::sort(orbital_history_.begin(), orbital_history_.end(), [](const OrbitalHistoryEntry&lt;Torb, Tbase&gt; &amp; a, const OrbitalHistoryEntry&lt;Torb, Tbase&gt; &amp; b) {return std::get&lt;1&gt;(a).first &lt; std::get&lt;1&gt;(b).first;});\n\n        // and then the rest of the stack in decreasing iteration\n        // number so that we always remove the oldest vector (lowest\n        // index)\n        std::sort(orbital_history_.begin()+1, orbital_history_.end(), [](const OrbitalHistoryEntry&lt;Torb, Tbase&gt; &amp; a, const OrbitalHistoryEntry&lt;Torb, Tbase&gt; &amp; b) {return std::get&lt;2&gt;(a) &gt; std::get&lt;2&gt;(b);});\n\n        if(verbosity_&gt;=20) {\n          print_history();\n        }\n\n        // Drop last entry if we are over the history length limit\n        if((int) orbital_history_.size() &gt; maximum_history_length_)\n          orbital_history_.pop_back();\n\n        return return_value;\n      }\n    }\n\n    void print_history() const {\n      printf(\"Orbital history\\n\");\n      for(size_t ihist=0;ihist&lt;orbital_history_.size();ihist++)\n        printf(\"%2i % .9f % e % i\\n\",(int) ihist, get_energy(ihist), get_energy(ihist)-get_energy(), (int) get_index(ihist));\n    }\n\n    void reset_history() {\n      while(orbital_history_.size()&gt;1)\n        orbital_history_.pop_back();\n    }\n\n    DiagonalizedFockMatrix&lt;Torb,Tbase&gt; compute_orbitals(const FockMatrix&lt;Torb&gt; &amp; fock) const {\n      DiagonalizedFockMatrix&lt;Torb, Tbase&gt; diagonalized_fock;\n      // Allocate memory for orbitals and orbital energies\n      diagonalized_fock.first.resize(fock.size());\n      diagonalized_fock.second.resize(fock.size());\n\n      // Diagonalize all blocks\n      for(size_t iblock = 0; iblock &lt; fock.size(); iblock++) {\n        if(fock[iblock].n_elem==0)\n          continue;\n        // Symmetrize Fock matrix\n        arma::Mat&lt;Torb&gt; fsymm(0.5*(fock[iblock]+fock[iblock].t()));\n        arma::eig_sym(diagonalized_fock.second[iblock], diagonalized_fock.first[iblock], fsymm);\n\n        if(verbosity_&gt;=10) {\n          diagonalized_fock.second[iblock].t().print(block_descriptions_[iblock] + \" orbital energies\");\n        }\n        fflush(stdout);\n      }\n\n      return diagonalized_fock;\n    }\n\n    arma::uword particle_block_offset(size_t iparticle) const {\n      return (iparticle&gt;0) ? arma::sum(number_of_blocks_per_particle_type_.subvec(0,iparticle-1)) : 0;\n    }\n\n    arma::Col&lt;Tbase&gt; determine_number_of_particles_by_aufbau(const OrbitalEnergies&lt;Tbase&gt; &amp; orbital_energies) const {\n      arma::Col&lt;Tbase&gt; number_of_particles(number_of_blocks_, arma::fill::zeros);\n\n      // Loop over particle types\n      for(size_t particle_type = 0; particle_type &lt; number_of_blocks_per_particle_type_.size(); particle_type++) {\n        // Compute the offset in the block array\n        size_t block_offset = particle_block_offset(particle_type);\n\n        // Collect the orbital energies with the block index and the in-block index for this particle type\n        std::vector&lt;std::tuple&lt;Tbase, size_t, size_t&gt;&gt; all_energies;\n        for(size_t iblock = block_offset; iblock &lt; block_offset + number_of_blocks_per_particle_type_(particle_type); iblock++)\n          for(size_t iorb = 0; iorb &lt; orbital_energies[iblock].size(); iorb++)\n            all_energies.push_back(std::make_tuple(orbital_energies[iblock](iorb), iblock, iorb));\n\n        // Sort the energies in increasing order\n        std::stable_sort(all_energies.begin(), all_energies.end(), [](const std::tuple&lt;Tbase, size_t, size_t&gt; &amp; a, const std::tuple&lt;Tbase, size_t, size_t&gt; &amp; b) {return std::get&lt;0&gt;(a) &lt; std::get&lt;0&gt;(b);});\n\n        // Fill the orbitals in increasing energy. This is how many\n        // particles we have to place\n        Tbase num_left = number_of_particles_(particle_type);\n        for(auto fill_orbital : all_energies) {\n          // Increase number of occupied orbitals\n          auto iblock = std::get&lt;1&gt;(fill_orbital);\n          // Compute how many particles fit this orbital\n          auto fill = std::min(maximum_occupation_(iblock), num_left);\n          number_of_particles(iblock) += fill;\n          num_left -= fill;\n          // This should be sufficently tolerant to roundoff error\n          if(num_left &lt;= 10*std::numeric_limits&lt;Tbase&gt;::epsilon())\n            break;\n        }\n      }\n\n      return number_of_particles;\n    }\n\n    OrbitalOccupations&lt;Tbase&gt; update_occupations(const OrbitalEnergies&lt;Tbase&gt; &amp; orbital_energies) const {\n      if(frozen_occupations_)\n        return get_orbital_occupations();\n\n      // Number of particles per block\n      arma::Col&lt;Tbase&gt; number_of_particles = (fixed_number_of_particles_per_block_.n_elem == number_of_blocks_) ? fixed_number_of_particles_per_block_ : determine_number_of_particles_by_aufbau(orbital_energies);\n\n      // Determine the number of occupied orbitals\n      OrbitalOccupations&lt;Tbase&gt; occupations(orbital_energies.size());\n      for(size_t iblock=0; iblock&lt;orbital_energies.size(); iblock++) {\n        if(orbital_energies[iblock].n_elem==0)\n          continue;\n        occupations[iblock].zeros(orbital_energies[iblock].size());\n\n        Tbase num_left = number_of_particles(iblock);\n        for(size_t iorb=0; iorb &lt; occupations[iblock].n_elem; iorb++) {\n          auto fill = std::min(maximum_occupation_(iblock), num_left);\n          occupations[iblock](iorb) = fill;\n          num_left -= fill;\n          // This should be sufficently tolerant to roundoff error\n          if(num_left &lt;= 10*std::numeric_limits&lt;Tbase&gt;::epsilon())\n            break;\n        }\n      }\n\n      return occupations;\n    }\n\n    bool converged() const {\n      return norm(diis_error_vector(0)) &lt;= convergence_threshold_;\n    }\n\n    void run() {\n      Tbase old_energy = 0.0;\n      // Number of consecutive steps that the procedure failed to decrease the energy\n      int failed_iterations = 0;\n      size_t noda_steps = 0;\n      for(size_t iteration=1; iteration &lt;= maximum_iterations_; iteration++) {\n        // Compute DIIS error\n        Tbase diis_error = norm(diis_error_vector(0));\n        Tbase diis_max_error = arma::norm(diis_error_vector(0),\"inf\");\n        Tbase dE = get_energy() - old_energy;\n\n        // Data to pass to callback function\n        std::map&lt;std::string, std::any&gt; callback_data;\n        callback_data[\"iter\"] = iteration;\n        callback_data[\"nfock\"] = number_of_fock_evaluations_;\n        callback_data[\"E\"] = get_energy();\n        callback_data[\"dE\"] = get_energy() - old_energy;\n        callback_data[\"diis_error\"] = diis_error;\n        callback_data[\"diis_max_error\"] = diis_max_error;\n\n        if(verbosity_&gt;=5) {\n          printf(\"\\n\\n\");\n        }\n        if(verbosity_&gt;0) {\n          printf(\"Iteration %i: %i Fock evaluations energy % .10f change % e DIIS error vector %s norm %e\\n\", (int) iteration, (int) number_of_fock_evaluations_, get_energy(), dE, error_norm_.c_str(), diis_error);\n        }\n        if(verbosity_&gt;=5) {\n          printf(\"History size %i\\n\",(int) orbital_history_.size());\n        }\n        if(converged()) {\n          if(verbosity_)\n            printf(\"Converged to energy % .10f!\\n\", get_energy());\n\n          // Print out info\n          callback_data[\"step\"] = std::string(\"Converged\");\n          if(callback_function_)\n            callback_function_(callback_data);\n          break;\n        }\n\n        if(verbosity_&gt;=5) {\n          const auto occupations = get_orbital_occupations();\n          auto occ_idx(occupied_orbitals(occupations));\n          for(size_t l=0;l&lt;occ_idx.size();l++) {\n            if(occ_idx[l].n_elem)\n              occupations[l].subvec(0,arma::max(occ_idx[l])).t().print(block_descriptions_[l] + \" occupations\");\n          }\n        }\n\n        if(noda_steps == 0) {\n          if(failed_iterations &gt;= maximum_history_length_/2) {\n            // Run the same number of steps using ODA\n            noda_steps = maximum_history_length_/2;\n            if(verbosity_&gt;=5) {\n              printf(\"Switching to optimal damping for next iterations\\n\");\n            }\n          }\n          if(diis_max_error &gt;= optimal_damping_threshold_) {\n            // The orbitals are so bad we can't trust A/EDIIS or DIIS\n            noda_steps = 1;\n          }\n        }\n\n        // Do ODA if necessary\n        if(noda_steps&gt;0) {\n          noda_steps--;\n          old_energy = get_energy();\n          if(verbosity_&gt;=5) {\n            if(diis_max_error &gt;= optimal_damping_threshold_)\n              printf(\"Optimal damping step due to large DIIS max error %e\\n\", diis_max_error);\n            else\n              printf(\"Optimal damping step\\n\");\n          }\n          callback_data[\"step\"] = std::string(\"ODA\");\n          if(callback_function_)\n            callback_function_(callback_data);\n          if(optimal_damping_step())\n            failed_iterations=0;\n\n        } else {\n          // Compute mixing factor (Garza and Scuseria, 2012)\n          Tbase aediis_coeff;\n          if(diis_error &lt; diis_threshold_) {\n            // If error is small, use pure DIIS\n            aediis_coeff = 0.0;\n          } else {\n            if(diis_error &lt; diis_epsilon_) {\n              // Compute AEDIIS mixing coefficient\n              aediis_coeff = (diis_error-diis_threshold_)/(diis_epsilon_-diis_threshold_);\n            } else {\n              // Error is large, use A/EDIIS\n              aediis_coeff = 1.0;\n            }\n          }\n          arma::Col&lt;Tbase&gt; weights;\n          std::string step;\n          std::tie(weights, step) = minimal_error_sampling_algorithm_weights(aediis_coeff);\n          if(verbosity_&gt;=5)\n            printf(\"%s step\\n\",step.c_str());\n          if(verbosity_&gt;=10)\n            weights.t().print(\"Extrapolation weights\");\n\n          // Do the callback\n          callback_data[\"step\"] = step;\n          if(callback_function_)\n            callback_function_(callback_data);\n\n          // Perform extrapolation.\n          old_energy = get_energy();\n          if(!attempt_extrapolation(weights)) {\n            if(verbosity_&gt;=10) printf(\"Warning: did not go down in energy!\\n\");\n            // Increment number of consecutive failed iterations\n            failed_iterations++;\n          } else {\n            // Step succeeded, reset counter\n            failed_iterations=0;\n          }\n        }\n        // Do cleanup\n        cleanup();\n      }\n    }\n\n    void run_optimal_damping() {\n      Tbase old_energy = 0.0;\n      for(size_t iteration=1; iteration &lt;= maximum_iterations_; iteration++) {\n        // Compute DIIS error\n        Tbase diis_error = norm(diis_error_vector(0));\n        Tbase diis_max_error = arma::norm(diis_error_vector(0),\"inf\");\n        Tbase dE = get_energy() - old_energy;\n\n        if(verbosity_&gt;=5) {\n          printf(\"\\n\\n\");\n        }\n        if(verbosity_&gt;0) {\n          printf(\"Iteration %i: %i Fock evaluations energy % .10f change % e DIIS error vector %s norm %e\\n\", (int) iteration, (int) number_of_fock_evaluations_, get_energy(), dE, error_norm_.c_str(), diis_error);\n        }\n\n        // Data to pass to callback function\n        std::map&lt;std::string, std::any&gt; callback_data;\n        callback_data[\"iter\"] = iteration;\n        callback_data[\"nfock\"] = number_of_fock_evaluations_;\n        callback_data[\"E\"] = get_energy();\n        callback_data[\"dE\"] = get_energy() - old_energy;\n        callback_data[\"diis_error\"] = diis_error;\n        callback_data[\"diis_max_error\"] = diis_max_error;\n        callback_data[\"step\"] = std::string(\"ODA\");\n\n        // Convergence check\n        if(converged()) {\n          if(verbosity_&gt;0) {\n            printf(\"Converged to energy % .10f\\n\", get_energy());\n          }\n          callback_data[\"step\"] = std::string(\"Converged\");\n          if(callback_function_)\n            callback_function_(callback_data);\n          break;\n        }\n\n        // Printout\n        if(callback_function_)\n          callback_function_(callback_data);\n\n        old_energy = get_energy();\n        if(not optimal_damping_step())\n          throw std::logic_error(\"Could not find descent step!\\n\");\n\n        if(verbosity_&gt;=5) {\n          const auto occupations = get_orbital_occupations();\n          auto occ_idx(occupied_orbitals(occupations));\n          for(size_t l=0;l&lt;occ_idx.size();l++) {\n            if(occ_idx[l].n_elem)\n              occupations[l].subvec(0,arma::max(occ_idx[l])).t().print(block_descriptions_[l] + \" occupations\");\n          }\n        }\n      }\n    }\n\n    DensityMatrix&lt;Torb, Tbase&gt; get_solution(size_t ihist=0) const {\n      return std::get&lt;0&gt;(orbital_history_[ihist]);\n    }\n\n    Orbitals&lt;Torb&gt; get_orbitals(size_t ihist=0) const {\n      return std::get&lt;0&gt;(orbital_history_[ihist]).first;\n    }\n\n    OrbitalOccupations&lt;Tbase&gt; get_orbital_occupations(size_t ihist=0) const {\n      return std::get&lt;0&gt;(orbital_history_[ihist]).second;\n    }\n\n    FockBuilderReturn&lt;Torb, Tbase&gt; get_fock_build(size_t ihist=0) const {\n      return std::get&lt;1&gt;(orbital_history_[ihist]);\n    }\n\n    FockMatrix&lt;Torb&gt; get_fock_matrix(size_t ihist=0) const {\n      return std::get&lt;1&gt;(orbital_history_[ihist]).second;\n    }\n\n\n    void brute_force_search_for_lowest_configuration() {\n      // Make sure we have a solution\n      if(orbital_history_.size() == 0)\n        run();\n      else {\n        Tbase diis_error = norm(diis_error_vector(0));\n        if(diis_error &gt;= diis_threshold_)\n          run();\n      }\n\n      // Get the reference orbitals and orbital occupations\n      auto reference_solution = orbital_history_[0];\n      auto reference_orbitals = get_orbitals();\n      auto reference_occupations = get_orbital_occupations();\n      auto reference_energy = get_energy();\n      auto reference_fock = get_fock_matrix();\n\n      // We also need the orbital energies below\n      auto diagonalized_fock = compute_orbitals(reference_fock);\n      const auto &amp; orbital_energies = diagonalized_fock.second;\n\n      verbosity_ = 0;\n      frozen_occupations_ = false;\n      while(true) {\n        // Count the number of particles in each block\n        arma::Col&lt;Tbase&gt; number_of_particles_per_block(number_of_blocks_,arma::fill::zeros);\n        for(size_t iblock=0; iblock&lt;number_of_particles_per_block.size(); iblock++) {\n          if(empty_block(iblock))\n            continue;\n          number_of_particles_per_block[iblock] = arma::sum(reference_occupations[iblock]);\n        }\n        number_of_particles_per_block.t().print(\"Number of particles per block\");\n\n        // List of occupations and resulting energies\n        std::vector&lt;std::pair&lt;arma::Col&lt;Tbase&gt;,Tbase&gt;&gt; list_of_energies;\n\n        // Loop over particle types. We have a double loop, since finding the lowest state in UHF probably requires this\n        for(size_t iparticle=0; iparticle&lt;number_of_blocks_per_particle_type_.n_elem; iparticle++) {\n          size_t iblock_start = particle_block_offset(iparticle);\n          size_t iblock_end = iblock_start + number_of_blocks_per_particle_type_(iparticle);\n\n          // One-particle moves\n          for(size_t iblock_source = iblock_start; iblock_source &lt; iblock_end; iblock_source++)\n            for(size_t iblock_target = iblock_start; iblock_target &lt; iblock_end; iblock_target++) {\n              if(iblock_source == iblock_target)\n                continue;\n\n              // Maximum number to move\n              Tbase num_i_source = number_of_particles_per_block[iblock_source];\n              Tbase i_target_capacity = reference_occupations[iblock_target].n_elem*maximum_occupation_[iblock_target];\n              Tbase i_target_capacity_left = i_target_capacity - arma::sum(reference_occupations[iblock_target]);\n              int num_i_max = std::ceil(std::min(num_i_source, i_target_capacity_left));\n              num_i_max = std::min(num_i_max, (int) std::round(std::min(maximum_occupation_[iblock_source], maximum_occupation_[iblock_target])));\n\n              // Generate trials by moving particles\n              for(int imove=1; imove&lt;=num_i_max; imove++) {\n                // Modify the occupations\n                auto trial_number(number_of_particles_per_block);\n                Tbase i_moved = std::min((Tbase) imove, trial_number(iblock_source));\n                trial_number(iblock_source) -= i_moved;\n                trial_number(iblock_target) += i_moved;\n\n                if(trial_number(iblock_source) &lt; 0.0 or trial_number(iblock_target) &gt; i_target_capacity)\n                  continue;\n\n                fixed_number_of_particles_per_block_ = trial_number;\n\n                printf(\"isource = %i itarget = %i imoved = %f\\n\", iblock_source, iblock_target, i_moved);\n                trial_number.t().print(\"trial number of particles\");\n                fflush(stdout);\n\n                // Determine full orbital occupations from the specified data. Because we've fixed the number of particles in each block, it doesn't matter that the orbital energies aren't correct\n                auto trial_occupations = update_occupations(orbital_energies);\n                initialize_with_orbitals(reference_orbitals, trial_occupations);\n                try {\n                  run();\n                } catch(...) {};\n                // Add the result to the list\n                list_of_energies.push_back(std::make_pair(trial_number, get_energy()));\n                // Reset the restriction\n                arma::Col&lt;Tbase&gt; dummy;\n                fixed_number_of_particles_per_block_ = dummy;\n              }\n            }\n\n          for(size_t jparticle=0; jparticle&lt;=iparticle; jparticle++) {\n            size_t jblock_start = particle_block_offset(jparticle);\n            size_t jblock_end = jblock_start + number_of_blocks_per_particle_type_(jparticle);\n\n            // Loop over blocks of particles\n            for(size_t iblock_source = iblock_start; iblock_source &lt; iblock_end; iblock_source++)\n              for(size_t iblock_target = iblock_start; iblock_target &lt; iblock_end; iblock_target++) {\n\n                bool same_particle = (iparticle == jparticle);\n                size_t jblock_source_end = same_particle ? iblock_source+1 : jblock_end;\n                size_t jblock_target_end = same_particle ? iblock_target+1 : jblock_end;\n                printf(\"iparticle= %i jparticle= %i isource=%i itarget=%i\\n\",iparticle,jparticle,iblock_source,iblock_target);\n\n                for(size_t jblock_source = jblock_start; jblock_source &lt; jblock_source_end; jblock_source++)\n                  for(size_t jblock_target = jblock_start; jblock_target &lt; jblock_target_end; jblock_target++) {\n                    // Skip trivial cases\n                    if(iblock_source == iblock_target and jblock_source == jblock_target)\n                      continue;\n                    if(iblock_source == jblock_target and jblock_source == iblock_target)\n                      continue;\n                    // Skip one-particle cases\n                    if(iblock_source == jblock_source and iblock_target == jblock_target)\n                      continue;\n\n                    // Maximum number to move\n                    Tbase num_i_source = number_of_particles_per_block[iblock_source];\n                    Tbase i_target_capacity = reference_occupations[iblock_target].n_elem*maximum_occupation_[iblock_target];\n                    Tbase i_target_capacity_left = i_target_capacity - arma::sum(reference_occupations[iblock_target]);\n                    int num_i_max = std::ceil(std::min(num_i_source, i_target_capacity_left));\n                    num_i_max = std::min(num_i_max, (int) std::round(std::min(maximum_occupation_[iblock_source], maximum_occupation_[iblock_target])));\n\n                    Tbase num_j_source = number_of_particles_per_block[jblock_source];\n                    Tbase j_target_capacity = reference_occupations[jblock_target].n_elem*maximum_occupation_[jblock_target];\n                    Tbase j_target_capacity_left = j_target_capacity - arma::sum(reference_occupations[jblock_target]);\n                    int num_j_max = std::ceil(std::min(num_j_source, j_target_capacity_left));\n                    num_j_max = std::min(num_j_max, (int) std::round(std::min(maximum_occupation_[jblock_source], maximum_occupation_[jblock_target])));\n\n                    printf(\"i: source %f capacity left %f num max %i\\n\",num_i_source,i_target_capacity_left,num_i_max);\n                    printf(\"j: source %f capacity left %f num max %i\\n\",num_j_source,j_target_capacity_left,num_j_max);\n                    fflush(stdout);\n\n                    // Generate trials by moving particles\n                    for(int imove=1; imove&lt;=num_i_max; imove++)\n                      for(int jmove=1; jmove&lt;=num_j_max; jmove++) {\n                        // These also lead to degeneracies\n                        if(iblock_source == iblock_target and imove &gt; 0)\n                          continue;\n                        if(iblock_source == iblock_target and jmove == 0)\n                          continue;\n                        if(jblock_source == jblock_target and jmove &gt; 0)\n                          continue;\n                        if(jblock_source == jblock_target and imove == 0)\n                          continue;\n\n                        // Modify the occupations\n                        auto trial_number(number_of_particles_per_block);\n                        Tbase i_moved = std::min((Tbase) imove, trial_number(iblock_source));\n                        trial_number(iblock_source) -= i_moved;\n                        trial_number(iblock_target) += i_moved;\n                        Tbase j_moved = std::min((Tbase) jmove, trial_number(jblock_source));\n                        trial_number(jblock_source) -= j_moved;\n                        trial_number(jblock_target) += j_moved;\n\n                        if(trial_number(iblock_source) &lt; 0.0 or trial_number(jblock_source) &lt; 0.0)\n                          continue;\n                        if(trial_number(iblock_target) &gt; i_target_capacity)\n                          continue;\n                        if(trial_number(jblock_target) &gt; j_target_capacity)\n                          continue;\n\n                        fixed_number_of_particles_per_block_ = trial_number;\n\n                        printf(\"isource = %i itarget = %i imoved = %f\\n\", iblock_source, iblock_target, i_moved);\n                        printf(\"jsource = %i jtarget = %i jmoved = %f\\n\", jblock_source, jblock_target, j_moved);\n                        trial_number.t().print(\"trial number of particles\");\n                        fflush(stdout);\n\n                        // Determine full orbital occupations from the specified data. Because we've fixed the number of particles in each block, it doesn't matter that the orbital energies aren't correct\n                        auto trial_occupations = update_occupations(orbital_energies);\n                        initialize_with_orbitals(reference_orbitals, trial_occupations);\n                        try {\n                          run();\n                        } catch(...) {};\n                        // Add the result to the list\n                        list_of_energies.push_back(std::make_pair(trial_number, get_energy()));\n                        // Reset the restriction\n                        arma::Col&lt;Tbase&gt; dummy;\n                        fixed_number_of_particles_per_block_ = dummy;\n                      }\n                  }\n              }\n          }\n        }\n\n        // Sort the list in ascending order\n        std::sort(list_of_energies.begin(), list_of_energies.end(), [](const std::pair&lt;arma::Col&lt;Tbase&gt;,Tbase&gt; &amp; a, const std::pair&lt;arma::Col&lt;Tbase&gt;,Tbase&gt; &amp; b) {return a.second &lt; b.second;});\n\n        printf(\"Configurations\\n\");\n        for(size_t iconf=0;iconf&lt;list_of_energies.size();iconf++) {\n          printf(\"%4i E= % .10f with occupations\\n\",(int) iconf, list_of_energies[iconf].second);\n          list_of_energies[iconf].first.t().print();\n        }\n\n        if(list_of_energies[0].second &lt; reference_energy) {\n          printf(\"Energy changed by %e by improved reference\\n\", list_of_energies[0].second - reference_energy);\n\n          // Update the reference\n          fixed_number_of_particles_per_block_ = list_of_energies[0].first;\n          auto trial_occupations = update_occupations(orbital_energies);\n          initialize_with_orbitals(reference_orbitals, trial_occupations);\n          run();\n\n          reference_solution = orbital_history_[0];\n          reference_orbitals = get_orbitals();\n          reference_occupations = get_orbital_occupations();\n          reference_energy = get_energy();\n          reference_fock = get_fock_matrix();\n        } else {\n          // Restore the reference calculation\n          initialize_with_orbitals(reference_orbitals, reference_occupations);\n          run();\n          printf(\"Search converged!\\n\");\n          break;\n        }\n      }\n    }\n\n    void callback_function(std::function&lt;void(const std::map&lt;std::string,std::any&gt; &amp;)&gt; callback_function = nullptr) {\n      callback_function_ = callback_function;\n    }\n  };\n}\n</code></pre>"},{"location":"OOOApi/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace OpenOrbitalOptimizer <ul> <li>namespace ConjugateGradients </li> </ul> </li> </ul>"},{"location":"OOOApi/classes/","title":"Class Index","text":""},{"location":"OOOApi/classes/#s","title":"s","text":"<ul> <li>SCFSolver (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class OpenOrbitalOptimizer::SCFSolver SCF solver class. </li> </ul>"},{"location":"OOOApi/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"OOOApi/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"OOOApi/class_members/","title":"Class Members","text":""},{"location":"OOOApi/class_members/#a","title":"a","text":"<ul> <li>add_entry (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_linear_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_quadratic_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>aediis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>attempt_extrapolation (OpenOrbitalOptimizer::SCFSolver)</li> <li>attempt_fock (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#b","title":"b","text":"<ul> <li>block_descriptions_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>brute_force_search_for_lowest_configuration (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#c","title":"c","text":"<ul> <li>callback_function (OpenOrbitalOptimizer::SCFSolver)</li> <li>callback_function_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>cleanup (OpenOrbitalOptimizer::SCFSolver)</li> <li>compute_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>converged (OpenOrbitalOptimizer::SCFSolver)</li> <li>convergence_threshold (OpenOrbitalOptimizer::SCFSolver)</li> <li>convergence_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#d","title":"d","text":"<ul> <li>degrees_of_freedom (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_matrix_difference (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_overlap (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_projection (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_restart_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>determine_maximum_overlap_occupations (OpenOrbitalOptimizer::SCFSolver)</li> <li>determine_number_of_particles_by_aufbau (OpenOrbitalOptimizer::SCFSolver)</li> <li>diagonal_orbital_hessian (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_diagonal_damping (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_diagonal_damping_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_epsilon (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_epsilon_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix_diagonal (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix_element (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_vector (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_residual (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_restart_factor (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_restart_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_threshold (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_weights (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#e","title":"e","text":"<ul> <li>ediis_linear_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>ediis_quadratic_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>ediis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>empty_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>error_norm (OpenOrbitalOptimizer::SCFSolver)</li> <li>error_norm_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>evaluate_rotation (OpenOrbitalOptimizer::SCFSolver)</li> <li>extrapolate_density (OpenOrbitalOptimizer::SCFSolver)</li> <li>extrapolate_fock (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#f","title":"f","text":"<ul> <li>fixed_number_of_particles_per_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>fixed_number_of_particles_per_block_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>fock_builder_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>form_rotation_matrices (OpenOrbitalOptimizer::SCFSolver)</li> <li>frozen_occupations (OpenOrbitalOptimizer::SCFSolver)</li> <li>frozen_occupations_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#g","title":"g","text":"<ul> <li>get_density_matrix_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_energy (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_build (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_matrix (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_matrix_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_lowest_energy_after_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_occupation_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_occupations (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_solution (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#i","title":"i","text":"<ul> <li>initial_level_shift_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>initialize_with_fock (OpenOrbitalOptimizer::SCFSolver)</li> <li>initialize_with_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#l","title":"l","text":"<ul> <li>largest_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>level_shift_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>level_shifting_step (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#m","title":"m","text":"<ul> <li>make_history_entry (OpenOrbitalOptimizer::SCFSolver)</li> <li>matricise (OpenOrbitalOptimizer::SCFSolver)</li> <li>matrix_dimension (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_history_length (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_history_length_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_iterations (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_iterations_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_occupation_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_rotation_step (OpenOrbitalOptimizer::SCFSolver)</li> <li>minimal_error_sampling_algorithm_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>minimal_gradient_projection_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#n","title":"n","text":"<ul> <li>norm (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_blocks_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_blocks_per_particle_type_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_fock_evaluations_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_particles_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#o","title":"o","text":"<ul> <li>occupation_difference (OpenOrbitalOptimizer::SCFSolver)</li> <li>occupied_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>occupied_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_step (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_threshold (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_gradient_vector (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_history_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_occupations_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#p","title":"p","text":"<ul> <li>particle_block_offset (OpenOrbitalOptimizer::SCFSolver)</li> <li>precondition_search_direction (OpenOrbitalOptimizer::SCFSolver)</li> <li>print_history (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#r","title":"r","text":"<ul> <li>reset_history (OpenOrbitalOptimizer::SCFSolver)</li> <li>rotate_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>run (OpenOrbitalOptimizer::SCFSolver)</li> <li>run_optimal_damping (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#s","title":"s","text":"<ul> <li>SCFSolver (OpenOrbitalOptimizer::SCFSolver)</li> <li>steepest_descent_step (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#u","title":"u","text":"<ul> <li>unoccupied_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>update_occupations (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_members/#v","title":"v","text":"<ul> <li>vectorise (OpenOrbitalOptimizer::SCFSolver)</li> <li>verbosity (OpenOrbitalOptimizer::SCFSolver)</li> <li>verbosity_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/","title":"Class Member Functions","text":""},{"location":"OOOApi/class_member_functions/#a","title":"a","text":"<ul> <li>add_entry (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_linear_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_quadratic_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>adiis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>aediis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>attempt_extrapolation (OpenOrbitalOptimizer::SCFSolver)</li> <li>attempt_fock (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#b","title":"b","text":"<ul> <li>brute_force_search_for_lowest_configuration (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#c","title":"c","text":"<ul> <li>callback_function (OpenOrbitalOptimizer::SCFSolver)</li> <li>cleanup (OpenOrbitalOptimizer::SCFSolver)</li> <li>compute_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>converged (OpenOrbitalOptimizer::SCFSolver)</li> <li>convergence_threshold (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#d","title":"d","text":"<ul> <li>degrees_of_freedom (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_matrix_difference (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_overlap (OpenOrbitalOptimizer::SCFSolver)</li> <li>density_projection (OpenOrbitalOptimizer::SCFSolver)</li> <li>determine_maximum_overlap_occupations (OpenOrbitalOptimizer::SCFSolver)</li> <li>determine_number_of_particles_by_aufbau (OpenOrbitalOptimizer::SCFSolver)</li> <li>diagonal_orbital_hessian (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_diagonal_damping (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_epsilon (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix_diagonal (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_matrix_element (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_error_vector (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_residual (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_restart_factor (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_threshold (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_weights (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#e","title":"e","text":"<ul> <li>ediis_linear_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>ediis_quadratic_term (OpenOrbitalOptimizer::SCFSolver)</li> <li>ediis_weights (OpenOrbitalOptimizer::SCFSolver)</li> <li>empty_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>error_norm (OpenOrbitalOptimizer::SCFSolver)</li> <li>evaluate_rotation (OpenOrbitalOptimizer::SCFSolver)</li> <li>extrapolate_density (OpenOrbitalOptimizer::SCFSolver)</li> <li>extrapolate_fock (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#f","title":"f","text":"<ul> <li>fixed_number_of_particles_per_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>form_rotation_matrices (OpenOrbitalOptimizer::SCFSolver)</li> <li>frozen_occupations (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#g","title":"g","text":"<ul> <li>get_density_matrix_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_energy (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_build (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_matrix (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_fock_matrix_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_lowest_energy_after_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_occupation_block (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbital_occupations (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>get_solution (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#i","title":"i","text":"<ul> <li>initialize_with_fock (OpenOrbitalOptimizer::SCFSolver)</li> <li>initialize_with_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#l","title":"l","text":"<ul> <li>largest_index (OpenOrbitalOptimizer::SCFSolver)</li> <li>level_shifting_step (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#m","title":"m","text":"<ul> <li>make_history_entry (OpenOrbitalOptimizer::SCFSolver)</li> <li>matricise (OpenOrbitalOptimizer::SCFSolver)</li> <li>matrix_dimension (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_history_length (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_iterations (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_rotation_step (OpenOrbitalOptimizer::SCFSolver)</li> <li>minimal_error_sampling_algorithm_weights (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#n","title":"n","text":"<ul> <li>norm (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#o","title":"o","text":"<ul> <li>occupation_difference (OpenOrbitalOptimizer::SCFSolver)</li> <li>occupied_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_step (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_threshold (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_gradient_vector (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#p","title":"p","text":"<ul> <li>particle_block_offset (OpenOrbitalOptimizer::SCFSolver)</li> <li>precondition_search_direction (OpenOrbitalOptimizer::SCFSolver)</li> <li>print_history (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#r","title":"r","text":"<ul> <li>reset_history (OpenOrbitalOptimizer::SCFSolver)</li> <li>rotate_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>run (OpenOrbitalOptimizer::SCFSolver)</li> <li>run_optimal_damping (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#s","title":"s","text":"<ul> <li>SCFSolver (OpenOrbitalOptimizer::SCFSolver)</li> <li>steepest_descent_step (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#u","title":"u","text":"<ul> <li>unoccupied_orbitals (OpenOrbitalOptimizer::SCFSolver)</li> <li>update_occupations (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_functions/#v","title":"v","text":"<ul> <li>vectorise (OpenOrbitalOptimizer::SCFSolver)</li> <li>verbosity (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/","title":"Class Member Variables","text":""},{"location":"OOOApi/class_member_variables/#b","title":"b","text":"<ul> <li>block_descriptions_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#c","title":"c","text":"<ul> <li>callback_function_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>convergence_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#d","title":"d","text":"<ul> <li>density_restart_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_diagonal_damping_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_epsilon_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_restart_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>diis_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#e","title":"e","text":"<ul> <li>error_norm_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#f","title":"f","text":"<ul> <li>fixed_number_of_particles_per_block_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>fock_builder_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>frozen_occupations_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#i","title":"i","text":"<ul> <li>initial_level_shift_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#l","title":"l","text":"<ul> <li>level_shift_factor_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#m","title":"m","text":"<ul> <li>maximum_history_length_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_iterations_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>maximum_occupation_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>minimal_gradient_projection_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#n","title":"n","text":"<ul> <li>number_of_blocks_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_blocks_per_particle_type_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_fock_evaluations_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>number_of_particles_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#o","title":"o","text":"<ul> <li>occupied_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>optimal_damping_threshold_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_history_ (OpenOrbitalOptimizer::SCFSolver)</li> <li>orbital_occupations_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_variables/#v","title":"v","text":"<ul> <li>verbosity_ (OpenOrbitalOptimizer::SCFSolver)</li> </ul>"},{"location":"OOOApi/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"OOOApi/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"OOOApi/namespace_members/","title":"Namespace Members","text":""},{"location":"OOOApi/namespace_members/#c","title":"c","text":"<ul> <li>cg_optimize (OpenOrbitalOptimizer::ConjugateGradients)</li> </ul>"},{"location":"OOOApi/namespace_members/#d","title":"d","text":"<ul> <li>DensityMatrix (OpenOrbitalOptimizer)</li> <li>DiagonalOrbitalHessianBlock (OpenOrbitalOptimizer)</li> <li>DiagonalOrbitalHessians (OpenOrbitalOptimizer)</li> <li>DiagonalizedFockMatrix (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_members/#f","title":"f","text":"<ul> <li>FockBuilder (OpenOrbitalOptimizer)</li> <li>FockBuilderReturn (OpenOrbitalOptimizer)</li> <li>FockMatrix (OpenOrbitalOptimizer)</li> <li>FockMatrixBlock (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_members/#o","title":"o","text":"<ul> <li>OrbitalBlock (OpenOrbitalOptimizer)</li> <li>OrbitalBlockOccupations (OpenOrbitalOptimizer)</li> <li>OrbitalEnergies (OpenOrbitalOptimizer)</li> <li>OrbitalGradientBlock (OpenOrbitalOptimizer)</li> <li>OrbitalGradients (OpenOrbitalOptimizer)</li> <li>OrbitalHistory (OpenOrbitalOptimizer)</li> <li>OrbitalHistoryEntry (OpenOrbitalOptimizer)</li> <li>OrbitalOccupations (OpenOrbitalOptimizer)</li> <li>OrbitalRotation (OpenOrbitalOptimizer)</li> <li>Orbitals (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"OOOApi/namespace_member_functions/#c","title":"c","text":"<ul> <li>cg_optimize (OpenOrbitalOptimizer::ConjugateGradients)</li> </ul>"},{"location":"OOOApi/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"OOOApi/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"OOOApi/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>DensityMatrix (OpenOrbitalOptimizer)</li> <li>DiagonalOrbitalHessianBlock (OpenOrbitalOptimizer)</li> <li>DiagonalOrbitalHessians (OpenOrbitalOptimizer)</li> <li>DiagonalizedFockMatrix (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>FockBuilder (OpenOrbitalOptimizer)</li> <li>FockBuilderReturn (OpenOrbitalOptimizer)</li> <li>FockMatrix (OpenOrbitalOptimizer)</li> <li>FockMatrixBlock (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_member_typedefs/#o","title":"o","text":"<ul> <li>OrbitalBlock (OpenOrbitalOptimizer)</li> <li>OrbitalBlockOccupations (OpenOrbitalOptimizer)</li> <li>OrbitalEnergies (OpenOrbitalOptimizer)</li> <li>OrbitalGradientBlock (OpenOrbitalOptimizer)</li> <li>OrbitalGradients (OpenOrbitalOptimizer)</li> <li>OrbitalHistory (OpenOrbitalOptimizer)</li> <li>OrbitalHistoryEntry (OpenOrbitalOptimizer)</li> <li>OrbitalOccupations (OpenOrbitalOptimizer)</li> <li>OrbitalRotation (OpenOrbitalOptimizer)</li> <li>Orbitals (OpenOrbitalOptimizer)</li> </ul>"},{"location":"OOOApi/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"OOOApi/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"OOOApi/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"OOOApi/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"OOOApi/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}